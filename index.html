<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>–ö–∞—Ä—Ç–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–æ—Ä—è</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        #menu-toggle { display: none; position: absolute; top: 16px; left: 16px; width: 44px; height: 44px; border-radius: 12px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border: none; box-shadow: 0 4px 20px rgba(0,0,0,0.15); cursor: pointer; z-index: 2; font-size: 20px; align-items: center; justify-content: center; }
        #menu { position: absolute; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 16px; top: 16px; left: 16px; border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); width: 220px; }
        #menu-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.08); }
        #menu-header h3 { margin: 0; font-size: 15px; font-weight: 600; color: #1a1a2e; }
        #menu-close { width: 28px; height: 28px; border-radius: 8px; background: transparent; border: none; cursor: pointer; font-size: 18px; color: #666; display: none; align-items: center; justify-content: center; }
        #menu-close:hover { background: rgba(0,0,0,0.06); }
        #menu h4 { margin: 16px 0 10px 0; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #888; }
        #menu h4:first-of-type { margin-top: 0; }
        .layer-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .layer-group button { border: none; background: #f0f2f5; padding: 10px 8px; border-radius: 8px; cursor: pointer; text-align: center; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; }
        .layer-group button:hover { background: #e4e6eb; }
        .layer-group button.active { background: linear-gradient(135deg, #3887be, #2d6a9f); color: white; box-shadow: 0 2px 8px rgba(56,135,190,0.3); }
        .select-wrapper { position: relative; }
        .select-wrapper::after { content: '\25BC'; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #888; pointer-events: none; }
        #year-select { width: 100%; padding: 10px 12px; border: none; background: #f0f2f5; border-radius: 8px; font-size: 14px; font-weight: 500; color: #333; cursor: pointer; appearance: none; }
        #year-select:hover { background: #e4e6eb; }
        #year-select:focus { outline: none; box-shadow: 0 0 0 2px rgba(56,135,190,0.3); }
        .horizon-group { display: flex; gap: 8px; }
        .horizon-btn { flex: 1; padding: 10px; border: none; background: #f0f2f5; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; text-align: center; }
        .horizon-btn:hover { background: #e4e6eb; }
        .horizon-btn.active { background: #1a1a2e; color: white; }
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0,0,0,0.08); }
        .toggle-row span { font-size: 13px; color: #444; }
        .toggle-switch { position: relative; width: 44px; height: 24px; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; border-radius: 24px; transition: 0.2s ease; }
        .toggle-slider::before { position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: 0.2s ease; }
        .toggle-switch input:checked + .toggle-slider { background: #3887be; }
        .toggle-switch input:checked + .toggle-slider::before { transform: translateX(20px); }
        #legend { position: absolute; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 12px 16px; bottom: 100px; right: 16px; border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); }
        .legend-key { display: inline-block; width: 14px; height: 14px; margin-right: 8px; vertical-align: middle; border-radius: 4px; }
        #legend h4 { margin: 0 0 10px 0; font-size: 13px; font-weight: 600; color: #1a1a2e; }
        #legend div { margin-bottom: 6px; font-size: 12px; color: #444; }
        .mapboxgl-popup-content { font-size: 14px; padding: 0; max-width: 700px; min-width: 600px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
        .mapboxgl-popup-content strong { color: #3887be; display: block; margin-bottom: 4px; font-size: 15px; }
        .mapboxgl-popup-content .popup-subheader { color: #666; font-size: 13px; margin-bottom: 8px; }
        .mapboxgl-popup-content table { width: 100%; margin-top: 10px; border-collapse: collapse; }
        .mapboxgl-popup-content td { padding: 4px 0; color: #555; }
        .mapboxgl-popup-content td:last-child { text-align: right; font-weight: 600; color: #333; padding-left: 12px; }
        .mapboxgl-popup-tip { border-top-color: white !important; }
        .mapboxgl-ctrl-logo, .mapboxgl-ctrl-attrib { display: none !important; }
        #custom-logo { position: absolute; bottom: 10px; left: 10px; z-index: 2; }
        #custom-logo img { height: 80px; width: auto; }
        #custom-attribution { position: absolute; bottom: 10px; right: 10px; z-index: 2; background-color: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px; font-size: 12px; }
        #custom-attribution a { color: #333; text-decoration: none; }
        #custom-attribution a:hover { text-decoration: underline; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255,255,255,0.9); z-index: 10; display: flex; justify-content: center; align-items: center; flex-direction: column; transition: opacity 0.3s ease; }
        .spinner { width: 48px; height: 48px; border: 4px solid #f0f2f5; border-top: 4px solid #3887be; border-radius: 50%; animation: spin 0.8s linear infinite; }
        #loader p { margin-top: 20px; font-size: 15px; color: #666; text-align: center; padding: 0 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .popup-chart-container { padding: 16px; }
        .popup-chart-container h5 { margin: 0 0 12px 0; font-size: 13px; font-weight: 600; color: #1a1a2e; text-align: center; }
        .popup-chart-wrapper { position: relative; height: 200px; margin-bottom: 16px; }
        .popup-chart-wrapper:last-child { margin-bottom: 0; }
        .popup-divider { height: 1px; background: rgba(0,0,0,0.08); margin: 0 16px; }
        #timeline-container { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); width: calc(100% - 240px); max-width: 1200px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-radius: 12px; padding: 12px 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 1; }
        #timeline-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        #timeline-current-date { font-size: 14px; font-weight: 600; color: #1a1a2e; }
        #timeline-play-btn { width: 32px; height: 32px; border-radius: 8px; border: none; background: #3887be; color: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: all 0.15s ease; }
        #timeline-play-btn:hover { background: #2d6a9f; }
        #timeline-slider-wrapper { position: relative; padding: 10px 0; }
        #timeline-slider { width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(to right, #e0e0e0 0%, #3887be 0%); outline: none; -webkit-appearance: none; cursor: pointer; }
        #timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #3887be; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        #timeline-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: #3887be; cursor: pointer; border: none; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        #timeline-ticks { position: absolute; top: 0; left: 0; right: 0; height: 6px; pointer-events: none; }
        .timeline-tick { position: absolute; width: 2px; height: 12px; background: #666; top: 8px; }
        .timeline-tick-label { position: absolute; font-size: 11px; color: #666; transform: translateX(-50%); top: 24px; white-space: nowrap; }
        @media (max-width: 900px) { #timeline-container { width: calc(100% - 32px); bottom: 110px; } }
        @media (max-width: 600px) { #menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; border-radius: 0; transform: translateX(-100%); overflow-y: auto; transition: transform 0.2s ease; } #menu.open { transform: translateX(0); } #menu-toggle { display: flex; } #menu-close { display: flex; } #legend { bottom: 100px; right: 10px; left: 10px; } }
    </style>
</head>
<body>
<div id="loader"><div class="spinner"></div><p id="loader-text">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</p></div>
<div id="map"></div>
<button id="menu-toggle">‚ò∞</button>
<div id="custom-logo"><img src="https://raw.githubusercontent.com/badmaev93/sea-map/refs/heads/main/150_logo75.png" alt="–î–í–ù–ò–ì–ú–ò"></div>
<div id="custom-attribution"><a href="https://www.mapbox.com/about/maps/" target="_blank">¬© Mapbox</a> | <a href="http://www.openstreetmap.org/copyright" target="_blank">¬© OpenStreetMap</a></div>
<div id="menu">
    <div id="menu-header"><h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3><button id="menu-close">‚úï</button></div>
    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä</h4>
    <div class="layer-group">
        <button id="btn-oxygen-points" class="active" data-param="oxygen">–ö–∏—Å–ª–æ—Ä–æ–¥</button>
        <button id="btn-ph-points" data-param="ph">pH</button>
    </div>
    <h4>–ì–æ—Ä–∏–∑–æ–Ω—Ç</h4>
    <div class="horizon-group">
        <button class="horizon-btn active" data-value="0">–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å</button>
        <button class="horizon-btn" data-value="–¥–Ω–æ">–î–Ω–æ</button>
    </div>
    <div class="toggle-row"><span>–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å–∏</span><label class="toggle-switch"><input type="checkbox" id="show-labels"><span class="toggle-slider"></span></label></div>
    <button id="download-btn" style="width: 100%; margin-top: 16px; padding: 12px; border: none; background: linear-gradient(135deg, #3887be, #2d6a9f); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.15s ease;">üì• –°–∫–∞—á–∞—Ç—å –∫–∞—Ä—Ç—É</button>
</div>
<div id="legend"></div>
<div id="timeline-container">
    <div id="timeline-header">
        <span id="timeline-current-date">–î–∞—Ç–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞</span>
        <button id="timeline-play-btn">‚ñ∂</button>
    </div>
    <div id="timeline-slider-wrapper">
        <input type="range" id="timeline-slider" min="0" max="100" value="0">
        <div id="timeline-ticks"></div>
    </div>
</div>
<script>
// –ü—É–±–ª–∏—á–Ω—ã–π —Ç–æ–∫–µ–Ω Mapbox (–±–µ–∑–æ–ø–∞—Å–µ–Ω –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)
mapboxgl.accessToken = 'pk.eyJ1IjoiYm9sZWc5MzQiLCJhIjoiY2syY3pjeXFyMjN5aTNobzZmZGl5cng3aiJ9.ADhGQN0rFnGwPCk53capfQ';
const map = new mapboxgl.Map({ container: 'map', style: 'mapbox://styles/mapbox/light-v10', center: [132.026960, 43.130572], zoom: 8.95, attributionControl: false, preserveDrawingBuffer: true });
const config = { scales: { oxygen: { title: '–ö–∏—Å–ª–æ—Ä–æ–¥, –º–≥/–ª', prop: 'oxygen_mgl', format: 1, breaks: [6, 8, 10], bands: ['#f46d43', '#d9ef8b', '#a6d96a', '#66bd63'], sizeConfig: { base: 16 } }, ph: { title: 'pH', prop: 'ph', format: 2, bands: ['#eff3ff', '#bdd7e7', '#6baed6'], sizeConfig: { base: 18 } } }, firstLabelLayerId: 'waterway-label' };
let fullData = [];
let state = { activeParam: 'oxygen', showLabels: false, horizon: '0', year: null, season: 'spring', selectedStation: null };
let timelineDates = [];
let timelineIndex = 0;
let timelineInterval = null;
let popupCharts = { active: null, others: null };

function formatNumber(value, decimalPlaces) { if (typeof value !== 'number' || !isFinite(value)) return '–Ω/–¥'; return value.toFixed(decimalPlaces).replace('.', ','); }
function formatFullDateTime(dateStr, timeStr) { if (!dateStr || !timeStr) return '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'; const dateParts = String(dateStr).split('/'); const timeParts = String(timeStr).split(':'); if (dateParts.length !== 3 || timeParts.length < 2) return '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç'; const [month, day, year] = dateParts; const [hour, minute] = timeParts; return `${String(day).padStart(2, '0')}.${String(month).padStart(2, '0')}.${year} ${hour}:${minute}`; }
function generateDynamicBreaks(data, prop, numSteps) { if (!data || data.length === 0) return []; const values = data.map(d => d.properties[prop]).filter(v => typeof v === 'number' && isFinite(v)); if (values.length < 2) return values.length > 0 ? [values[0], values[0]] : []; const min = Math.min(...values); const max = Math.max(...values); if (min === max) return [min, max]; const step = (max - min) / numSteps; return Array.from({length: numSteps + 1}, (_, i) => parseFloat((min + i * step).toFixed(2))); }
function calculateBounds(features) { const bounds = new mapboxgl.LngLatBounds(); features.forEach(f => bounds.extend(f.geometry.coordinates)); return bounds; }
function calculateOutlierBounds(values) { if (!values || values.length < 4) return null; const sorted = [...values].sort((a, b) => a - b); const q1 = sorted[Math.floor(sorted.length * 0.25)]; const q3 = sorted[Math.floor(sorted.length * 0.75)]; const iqr = q3 - q1; return { lower: q1 - 1.5 * iqr, upper: q3 + 1.5 * iqr }; }

function updateLegend() {
    const paramConfig = config.scales[state.activeParam];
    if (!paramConfig) { document.getElementById('legend').innerHTML = ''; return; }
    let content = `<h4>${paramConfig.title}</h4>`;
    const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
    if (state.activeParam === 'oxygen' && paramConfig.breaks) {
        const bands = paramConfig.bands;
        content += `<div><span class="legend-key" style="background:${bands[0]}"></span>&lt; ${formatNumber(breaks[0], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[1]}"></span>${formatNumber(breaks[0], 1)} ‚Äì ${formatNumber(breaks[1], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[2]}"></span>${formatNumber(breaks[1], 1)} ‚Äì ${formatNumber(breaks[2], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[3]}"></span>‚â• ${formatNumber(breaks[2], 1)}</div>`;
    } else {
        if (!breaks || breaks.length < 2) { document.getElementById('legend').innerHTML = content + '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'; return; }
        for (let i = 0; i < paramConfig.bands.length; i++) { if (breaks[i + 1]) content += `<div><span class="legend-key" style="background:${paramConfig.bands[i]}"></span>${formatNumber(breaks[i], paramConfig.format)} ‚Äì ${formatNumber(breaks[i + 1], paramConfig.format)}</div>`; }
    }
    document.getElementById('legend').innerHTML = content;
}

function parseDateTime(dateStr, timeStr) { if (!dateStr || !timeStr) return null; const dateParts = String(dateStr).split('/'); const timeParts = String(timeStr).split(':'); if (dateParts.length !== 3 || timeParts.length < 2) return null; const [month, day, year] = dateParts; const [hour, minute] = timeParts; return new Date(year, month - 1, day, hour, minute); }
function getSeason(dateStr) { if (!dateStr) return null; const dateParts = String(dateStr).split('/'); if (dateParts.length !== 3) return null; const month = parseInt(dateParts[0]); if (month >= 3 && month <= 5) return 'spring'; if (month >= 9 && month <= 11) return 'autumn'; return null; }

function updateLayers() {
    let yearFilteredFeatures = fullData.filter(f => String(f.properties.date).split('/')[2] === state.year);
    yearFilteredFeatures = yearFilteredFeatures.filter(f => getSeason(f.properties.date) === state.season);
    const filteredFeatures = yearFilteredFeatures.filter(f => String(f.properties.horizon) === state.horizon);
    const source = map.getSource('points-source');
    if (source) source.setData({ type: 'FeatureCollection', features: filteredFeatures });
    Object.keys(config.scales).forEach(param => {
        const isActive = param === state.activeParam;
        const pointLayerId = `${param}-points-layer`; const labelLayerId = `${param}-labels-layer`;
        if (isActive) {
            const paramConfig = config.scales[param];
            const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
            let colorExpression = '#cccccc';
            if (breaks && breaks.length > 1) { const colorStops = paramConfig.breaks ? paramConfig.breaks.flatMap((val, i) => [val, paramConfig.bands[i + 1]]) : breaks.slice(1).flatMap((val, i) => [val, paramConfig.bands[i + 1]]); colorExpression = ['step', ['get', paramConfig.prop], paramConfig.bands[0], ...colorStops]; }
            map.setPaintProperty(pointLayerId, 'circle-color', colorExpression);
            const outlierBounds = state.horizon === '0' ? paramConfig.surfaceOutlierBounds : paramConfig.bottomOutlierBounds;
            const radiusExpression = outlierBounds ? ['case', ['any', ['<', ['get', paramConfig.prop], outlierBounds.lower], ['>', ['get', paramConfig.prop], outlierBounds.upper]], paramConfig.sizeConfig.base * 1.6, paramConfig.sizeConfig.base] : paramConfig.sizeConfig.base;
            map.setPaintProperty(pointLayerId, 'circle-radius', radiusExpression);
        }
        if (map.getLayer(pointLayerId)) map.setLayoutProperty(pointLayerId, 'visibility', isActive ? 'visible' : 'none');
        if (map.getLayer(labelLayerId)) map.setLayoutProperty(labelLayerId, 'visibility', isActive && state.showLabels ? 'visible' : 'none');
    });
    updateLegend();
}

function destroyPopupCharts() {
    if (popupCharts.active) { popupCharts.active.destroy(); popupCharts.active = null; }
    if (popupCharts.others) { popupCharts.others.destroy(); popupCharts.others = null; }
}

function createPopupCharts(dataPoints, labels, currentDateIndex) {
    destroyPopupCharts();
    const pointBackgroundColors = labels.map((_, idx) => idx === currentDateIndex ? 'rgba(255, 99, 132, 1)' : 'rgba(56, 135, 190, 0.8)');
    const pointRadius = labels.map((_, idx) => idx === currentDateIndex ? 8 : 4);
    const pointBorderWidth = labels.map((_, idx) => idx === currentDateIndex ? 3 : 1);
    const activeParam = state.activeParam;
    const activeData = dataPoints.map(d => activeParam === 'oxygen' ? d.oxygen : d.ph);
    const activeColor = activeParam === 'oxygen' ? '#f46d43' : '#6baed6';
    const activeCtx = document.getElementById('popup-active-chart').getContext('2d');
    popupCharts.active = new Chart(activeCtx, { type: 'line', data: { labels, datasets: [{ label: activeParam === 'oxygen' ? '–ö–∏—Å–ª–æ—Ä–æ–¥, –º–≥/–ª' : 'pH', data: activeData, borderColor: activeColor, backgroundColor: `${activeColor}20`, fill: true, pointBackgroundColor: pointBackgroundColors, pointBorderColor: '#fff', pointRadius: pointRadius, pointBorderWidth: pointBorderWidth, tension: 0.3 }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } } }, scales: { x: { ticks: { maxRotation: 45, minRotation: 45, font: { size: 10 } }, grid: { display: false } }, y: { grid: { color: 'rgba(0,0,0,0.06)' }, ticks: { font: { size: 10 } } } } } });
    const othersDatasets = [];
    othersDatasets.push({ label: '–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞, ¬∞C', data: dataPoints.map(d => d.temp), borderColor: '#ff7f0e', backgroundColor: 'rgba(255, 127, 14, 0.1)', yAxisID: 'y-temp', pointBackgroundColor: pointBackgroundColors, pointBorderColor: '#fff', pointRadius: pointRadius.map(r => r - 1), pointBorderWidth: 1, tension: 0.3 });
    othersDatasets.push({ label: '–°–æ–ª—ë–Ω–æ—Å—Ç—å, PSU', data: dataPoints.map(d => d.salinity), borderColor: '#41b6c4', backgroundColor: 'rgba(65, 182, 196, 0.1)', yAxisID: 'y-salinity', pointBackgroundColor: pointBackgroundColors, pointBorderColor: '#fff', pointRadius: pointRadius.map(r => r - 1), pointBorderWidth: 1, tension: 0.3 });
    if (activeParam !== 'oxygen') { othersDatasets.push({ label: '–ö–∏—Å–ª–æ—Ä–æ–¥, –º–≥/–ª', data: dataPoints.map(d => d.oxygen), borderColor: '#f46d43', backgroundColor: 'rgba(244, 109, 67, 0.1)', yAxisID: 'y-oxygen', pointBackgroundColor: pointBackgroundColors, pointBorderColor: '#fff', pointRadius: pointRadius.map(r => r - 1), pointBorderWidth: 1, tension: 0.3 }); }
    else { othersDatasets.push({ label: 'pH', data: dataPoints.map(d => d.ph), borderColor: '#6baed6', backgroundColor: 'rgba(107, 174, 214, 0.1)', yAxisID: 'y-ph', pointBackgroundColor: pointBackgroundColors, pointBorderColor: '#fff', pointRadius: pointRadius.map(r => r - 1), pointBorderWidth: 1, tension: 0.3 }); }
    const othersCtx = document.getElementById('popup-others-chart').getContext('2d');
    popupCharts.others = new Chart(othersCtx, { type: 'line', data: { labels, datasets: othersDatasets }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: true, position: 'bottom', labels: { font: { size: 11 }, boxWidth: 12, padding: 8 } }, tooltip: { callbacks: { title: (items) => labels[items[0].dataIndex] } } }, scales: { x: { ticks: { maxRotation: 45, minRotation: 45, font: { size: 10 } }, grid: { display: false } }, 'y-temp': { type: 'linear', display: true, position: 'left', title: { display: true, text: '–¢–µ–º–ø., ¬∞C', font: { size: 10 } }, grid: { color: 'rgba(0,0,0,0.06)' }, ticks: { font: { size: 9 } } }, 'y-salinity': { type: 'linear', display: true, position: 'right', title: { display: true, text: '–°–æ–ª—ë–Ω., PSU', font: { size: 10 } }, grid: { drawOnChartArea: false }, ticks: { font: { size: 9 } } }, 'y-oxygen': activeParam !== 'oxygen' ? { type: 'linear', display: false, position: 'right' } : undefined, 'y-ph': activeParam === 'oxygen' ? { type: 'linear', display: false, position: 'right' } : undefined } } });
}

function createPopupWithCharts(lngLat, stationId) {
    const stationFeatures = fullData.filter(f => f.properties.station_id === stationId && String(f.properties.horizon) === state.horizon);
    const dataPoints = stationFeatures.map(f => ({ datetime: parseDateTime(f.properties.date, f.properties.time), date: f.properties.date, time: f.properties.time, temp: f.properties.temp_c, salinity: f.properties.salinity_psu, oxygen: f.properties.oxygen_mgl, ph: f.properties.ph })).filter(d => d.datetime !== null).sort((a, b) => a.datetime - b.datetime);
    if (dataPoints.length === 0) { new mapboxgl.Popup().setLngLat(lngLat).setHTML(`<div style="padding:16px;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç–∞–Ω—Ü–∏–∏ ${stationId}</div>`).addTo(map); return; }
    const labels = dataPoints.map(d => { const day = String(d.datetime.getDate()).padStart(2, '0'); const month = String(d.datetime.getMonth() + 1).padStart(2, '0'); const year = d.datetime.getFullYear(); return `${day}.${month}.${year}`; });
    const currentDateIndex = dataPoints.findIndex(d => { const year = String(d.date).split('/')[2]; const season = getSeason(d.date); return year === state.year && season === state.season; });
    const popupHTML = `<div class="popup-chart-container"><h5>${state.activeParam === 'oxygen' ? '–ö–∏—Å–ª–æ—Ä–æ–¥, –º–≥/–ª' : 'pH'}</h5><div class="popup-chart-wrapper"><canvas id="popup-active-chart"></canvas></div></div><div class="popup-divider"></div><div class="popup-chart-container"><h5>–û—Å—Ç–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</h5><div class="popup-chart-wrapper"><canvas id="popup-others-chart"></canvas></div></div>`;
    const popup = new mapboxgl.Popup({ maxWidth: '700px' }).setLngLat(lngLat).setHTML(popupHTML).addTo(map);
    popup.on('open', () => { createPopupCharts(dataPoints, labels, currentDateIndex); });
    popup.on('close', () => { destroyPopupCharts(); });
}

function buildTimeline() {
    const dateMap = new Map();
    fullData.forEach(f => {
        const dateStr = f.properties.date;
        const year = String(dateStr).split('/')[2];
        const season = getSeason(dateStr);
        if (year && season) {
            const key = `${year}-${season}`;
            if (!dateMap.has(key)) {
                const seasonLabel = season === 'spring' ? '–í–µ—Å–Ω–∞' : '–û—Å–µ–Ω—å';
                dateMap.set(key, { year: year, season: season, label: `${seasonLabel} ${year}`, key: key });
            }
        }
    });
    timelineDates = Array.from(dateMap.values()).sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return a.season === 'spring' ? -1 : 1;
    });
    const slider = document.getElementById('timeline-slider');
    slider.max = timelineDates.length - 1;
    slider.value = timelineDates.length - 1;
    timelineIndex = timelineDates.length - 1;
    if (timelineDates.length > 0) {
        const current = timelineDates[timelineIndex];
        state.year = current.year;
        state.season = current.season;
        updateTimelineDisplay();
    }
    renderTimelineTicks();
}

function renderTimelineTicks() {
    const ticksContainer = document.getElementById('timeline-ticks');
    ticksContainer.innerHTML = '';
    const step = Math.max(1, Math.ceil(timelineDates.length / 8));
    timelineDates.forEach((date, index) => {
        if (index % step === 0 || index === timelineDates.length - 1) {
            const percent = (index / (timelineDates.length - 1)) * 100;
            const tick = document.createElement('div');
            tick.className = 'timeline-tick';
            tick.style.left = `${percent}%`;
            const label = document.createElement('div');
            label.className = 'timeline-tick-label';
            label.textContent = date.label;
            label.style.left = `${percent}%`;
            ticksContainer.appendChild(tick);
            ticksContainer.appendChild(label);
        }
    });
}

function updateTimelineDisplay() {
    const current = timelineDates[timelineIndex];
    document.getElementById('timeline-current-date').textContent = current.label;
    const slider = document.getElementById('timeline-slider');
    const percent = (timelineIndex / (timelineDates.length - 1)) * 100;
    slider.style.background = `linear-gradient(to right, #3887be ${percent}%, #e0e0e0 ${percent}%)`;
}

function onTimelineChange(newIndex) {
    timelineIndex = newIndex;
    const current = timelineDates[timelineIndex];
    state.year = current.year;
    state.season = current.season;
    updateTimelineDisplay();
    updateLayers();
}

function toggleTimelinePlay() {
    const btn = document.getElementById('timeline-play-btn');
    if (timelineInterval) {
        clearInterval(timelineInterval);
        timelineInterval = null;
        btn.textContent = '‚ñ∂';
    } else {
        btn.textContent = '‚è∏';
        timelineInterval = setInterval(() => {
            let nextIndex = timelineIndex + 1;
            if (nextIndex >= timelineDates.length) {
                nextIndex = 0;
            }
            document.getElementById('timeline-slider').value = nextIndex;
            onTimelineChange(nextIndex);
        }, 1500);
    }
}

function downloadMapAsImage() {
    const mapCanvas = map.getCanvas();
    const padding = 40;
    const headerHeight = 80;
    const legendWidth = 250;
    const legendPadding = 20;

    const canvas = document.createElement('canvas');
    canvas.width = mapCanvas.width + padding * 2;
    canvas.height = mapCanvas.height + padding * 2 + headerHeight;
    const ctx = canvas.getContext('2d');

    // –ë–µ–ª—ã–π —Ñ–æ–Ω
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫
    const paramConfig = config.scales[state.activeParam];
    const seasonText = state.season === 'spring' ? '–í–µ—Å–Ω–∞' : '–û—Å–µ–Ω—å';
    const horizonText = state.horizon === '0' ? '–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å' : '–î–Ω–æ';

    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText(`${paramConfig.title} ‚Äì ${state.year} –≥., ${seasonText}`, padding, padding + 30);

    ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#666';
    ctx.fillText(`–ì–æ—Ä–∏–∑–æ–Ω—Ç: ${horizonText}`, padding, padding + 55);

    // –ö–∞—Ä—Ç–∞
    ctx.drawImage(mapCanvas, padding, padding + headerHeight);

    // –õ–µ–≥–µ–Ω–¥–∞
    const legendX = canvas.width - legendWidth - padding;
    const legendY = padding + headerHeight + 20;

    // –§–æ–Ω –ª–µ–≥–µ–Ω–¥—ã
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.shadowColor = 'rgba(0,0,0,0.15)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 4;
    ctx.fillRect(legendX, legendY, legendWidth, 180);
    ctx.shadowColor = 'transparent';

    // –†–∞–º–∫–∞ –ª–µ–≥–µ–Ω–¥—ã
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    ctx.strokeRect(legendX, legendY, legendWidth, 180);

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ª–µ–≥–µ–Ω–¥—ã
    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText(paramConfig.title, legendX + legendPadding, legendY + legendPadding + 15);

    // –≠–ª–µ–º–µ–Ω—Ç—ã –ª–µ–≥–µ–Ω–¥—ã
    const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
    let yOffset = legendY + legendPadding + 40;
    const keySize = 14;
    const itemSpacing = 30;

    ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#444';

    if (state.activeParam === 'oxygen' && paramConfig.breaks) {
        const bands = paramConfig.bands;
        const labels = [
            `< ${formatNumber(breaks[0], 1)}`,
            `${formatNumber(breaks[0], 1)} ‚Äì ${formatNumber(breaks[1], 1)}`,
            `${formatNumber(breaks[1], 1)} ‚Äì ${formatNumber(breaks[2], 1)}`,
            `‚â• ${formatNumber(breaks[2], 1)}`
        ];

        labels.forEach((label, i) => {
            // –¶–≤–µ—Ç–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç
            ctx.fillStyle = bands[i];
            ctx.fillRect(legendX + legendPadding, yOffset - keySize + 2, keySize, keySize);

            // –¢–µ–∫—Å—Ç
            ctx.fillStyle = '#444';
            ctx.fillText(label, legendX + legendPadding + keySize + 10, yOffset);
            yOffset += itemSpacing;
        });
    } else {
        if (breaks && breaks.length >= 2) {
            for (let i = 0; i < paramConfig.bands.length && breaks[i + 1]; i++) {
                // –¶–≤–µ—Ç–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç
                ctx.fillStyle = paramConfig.bands[i];
                ctx.fillRect(legendX + legendPadding, yOffset - keySize + 2, keySize, keySize);

                // –¢–µ–∫—Å—Ç
                ctx.fillStyle = '#444';
                const label = `${formatNumber(breaks[i], paramConfig.format)} ‚Äì ${formatNumber(breaks[i + 1], paramConfig.format)}`;
                ctx.fillText(label, legendX + legendPadding + keySize + 10, yOffset);
                yOffset += itemSpacing;
            }
        }
    }

    // –°–∫–∞—á–∏–≤–∞–Ω–∏–µ
    canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `–∫–∞—Ä—Ç–∞_${state.activeParam}_${state.year}_${seasonText}_${horizonText}.png`;
        a.click();
        URL.revokeObjectURL(url);
    });
}

function setupControls() {
    document.querySelectorAll('.layer-group button').forEach(btn => { btn.addEventListener('click', e => { document.querySelectorAll('.layer-group button').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); state.activeParam = e.target.dataset.param; updateLayers(); }); });
    document.querySelectorAll('.horizon-btn').forEach(btn => { btn.addEventListener('click', e => { document.querySelectorAll('.horizon-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); state.horizon = e.target.dataset.value; updateLayers(); }); });
    document.getElementById('show-labels').addEventListener('change', e => { state.showLabels = e.target.checked; updateLayers(); });
    document.getElementById('download-btn').addEventListener('click', downloadMapAsImage);
    document.getElementById('timeline-slider').addEventListener('input', e => { onTimelineChange(parseInt(e.target.value)); });
    document.getElementById('timeline-play-btn').addEventListener('click', toggleTimelinePlay);
    document.getElementById('menu-toggle').addEventListener('click', () => document.getElementById('menu').classList.add('open'));
    document.getElementById('menu-close').addEventListener('click', () => document.getElementById('menu').classList.remove('open'));
}

async function fetchWithRetries(url, retries = 3, delay = 5000) { const loaderText = document.getElementById('loader-text'); for (let i = 0; i < retries; i++) { try { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 60000); const response = await fetch(url, { signal: controller.signal }); clearTimeout(timeoutId); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response; } catch (error) { if (i === 0 && loaderText) loaderText.innerHTML = "–°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...<br>–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞."; if (i === retries - 1) throw error; await new Promise(resolve => setTimeout(resolve, delay)); } } }

async function initializeMap() {
    const loader = document.getElementById('loader'); const loaderText = document.getElementById('loader-text');
    try {
        const response = await fetchWithRetries('https://sea-data-api.onrender.com/api/data');
        const rawData = await response.json();
        const validData = rawData.filter(p => p.longitude != null && p.latitude != null);
        validData.forEach(p => { p.datetime_full_formatted = formatFullDateTime(p.date, p.time); p.oxygen_mgl_formatted = formatNumber(p.oxygen_mgl, 1); p.temp_c_formatted = formatNumber(p.temp_c, 1); p.ph_formatted = formatNumber(p.ph, 2); p.salinity_psu_formatted = formatNumber(p.salinity_psu, 2); });
        fullData = validData.map(p => ({ type: 'Feature', geometry: { type: 'Point', coordinates: [p.longitude, p.latitude] }, properties: p }));
        Object.entries(config.scales).forEach(([param, paramConfig]) => { if (!paramConfig.breaks) { const surfaceData = fullData.filter(f => String(f.properties.horizon) === '0'); paramConfig.surfaceBreaks = generateDynamicBreaks(surfaceData, paramConfig.prop, paramConfig.bands.length); paramConfig.surfaceOutlierBounds = calculateOutlierBounds(surfaceData.map(f => f.properties[paramConfig.prop])); const bottomData = fullData.filter(f => String(f.properties.horizon) === '–¥–Ω–æ'); paramConfig.bottomBreaks = generateDynamicBreaks(bottomData, paramConfig.prop, paramConfig.bands.length); paramConfig.bottomOutlierBounds = calculateOutlierBounds(bottomData.map(f => f.properties[paramConfig.prop])); } });
        if (fullData.length > 0) { const bounds = calculateBounds(fullData); map.fitBounds(bounds, { padding: 50, duration: 0 }); const sw = bounds.getSouthWest(), ne = bounds.getNorthEast(); const lngDiff = ne.lng - sw.lng, latDiff = ne.lat - sw.lat, padding = 0.2; map.setMaxBounds(new mapboxgl.LngLatBounds([sw.lng - lngDiff * padding, sw.lat - latDiff * padding], [ne.lng + lngDiff * padding, ne.lat + latDiff * padding])); }
        map.addSource('points-source', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
        Object.entries(config.scales).forEach(([param, scale]) => { map.addLayer({ id: `${param}-points-layer`, type: 'circle', source: 'points-source', layout: { visibility: 'none' }, paint: { 'circle-color': '#cccccc', 'circle-stroke-width': 1.5, 'circle-stroke-color': '#fff', 'circle-radius': scale.sizeConfig.base } }, config.firstLabelLayerId); map.addLayer({ id: `${param}-labels-layer`, type: 'symbol', source: 'points-source', layout: { visibility: 'none', 'text-field': ['get', `${scale.prop}_formatted`], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10.5, 'text-allow-overlap': true, 'text-ignore-placement': true }, paint: { 'text-color': '#ffffff', 'text-halo-color': 'rgba(0, 0, 0, 0.85)', 'text-halo-width': 1.2 } }, config.firstLabelLayerId); });
        setupControls();
        buildTimeline();
        Object.keys(config.scales).forEach(param => { map.on('click', `${param}-points-layer`, e => { const props = e.features[0].properties; state.selectedStation = props.station_id; createPopupWithCharts(e.lngLat, props.station_id); }); map.on('mouseenter', `${param}-points-layer`, () => map.getCanvas().style.cursor = 'pointer'); map.on('mouseleave', `${param}-points-layer`, () => map.getCanvas().style.cursor = ''); });
        updateLayers();
        loader.style.opacity = 0; setTimeout(() => loader.style.display = 'none', 300);
    } catch (error) { console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ:", error); if (loaderText) { loader.querySelector('.spinner').style.display = 'none'; loaderText.innerHTML = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö.<br>–û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É."; } }
}

map.on('load', () => { map.setLanguage('ru'); initializeMap(); });
</script>
</body>
</html>
