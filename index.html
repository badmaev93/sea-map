<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Карта параметров моря</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        #menu-toggle { display: none; position: absolute; top: 16px; left: 16px; width: 44px; height: 44px; border-radius: 12px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border: none; box-shadow: 0 4px 20px rgba(0,0,0,0.15); cursor: pointer; z-index: 2; font-size: 20px; align-items: center; justify-content: center; }
        #menu { position: absolute; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 16px; top: 16px; left: 16px; border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); width: 220px; }
        #menu-header { display: flex; justify-content: flex-end; align-items: center; margin-bottom: 12px; }
        #menu-close { width: 28px; height: 28px; border-radius: 8px; background: transparent; border: none; cursor: pointer; font-size: 18px; color: #666; display: none; align-items: center; justify-content: center; }
        #menu-close:hover { background: rgba(0,0,0,0.06); }
        #menu h4 { margin: 16px 0 10px 0; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #888; }
        #menu h4:first-of-type { margin-top: 0; }
        .layer-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .layer-group button { border: none; background: #f0f2f5; padding: 10px 8px; border-radius: 8px; cursor: pointer; text-align: center; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; }
        .layer-group button:hover { background: #e4e6eb; }
        .layer-group button.active { background: linear-gradient(135deg, #3887be, #2d6a9f); color: white; box-shadow: 0 2px 8px rgba(56,135,190,0.3); }
        .select-wrapper { position: relative; }
        .select-wrapper::after { content: '\25BC'; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #888; pointer-events: none; }
        #year-select { width: 100%; padding: 10px 12px; border: none; background: #f0f2f5; border-radius: 8px; font-size: 14px; font-weight: 500; color: #333; cursor: pointer; appearance: none; }
        #year-select:hover { background: #e4e6eb; }
        #year-select:focus { outline: none; box-shadow: 0 0 0 2px rgba(56,135,190,0.3); }
        .horizon-group { display: flex; gap: 8px; }
        .horizon-btn { flex: 1; padding: 10px; border: none; background: #f0f2f5; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; text-align: center; }
        .horizon-btn:hover { background: #e4e6eb; }
        .horizon-btn.active { background: #1a1a2e; color: white; }
        .season-btn { flex: 1; padding: 10px; border: none; background: #f0f2f5; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; text-align: center; }
        .season-btn:hover { background: #e4e6eb; }
        .season-btn.active { background: #1a1a2e; color: white; }
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0,0,0,0.08); }
        .toggle-row span { font-size: 13px; color: #444; }
        .toggle-switch { position: relative; width: 44px; height: 24px; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; border-radius: 24px; transition: 0.2s ease; }
        .toggle-slider::before { position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: 0.2s ease; }
        .toggle-switch input:checked + .toggle-slider { background: #3887be; }
        .toggle-switch input:checked + .toggle-slider::before { transform: translateX(20px); }
        #legend { position: absolute; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 10px 12px; bottom: 80px; right: 16px; border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); width: 160px; font-size: 11px; }
        #legend h4 { font-size: 12px; margin-bottom: 8px; }
        #legend div { margin-bottom: 5px; font-size: 11px; }
        .legend-key { display: inline-block; width: 14px; height: 14px; margin-right: 8px; vertical-align: middle; border-radius: 4px; }
        #legend h4 { margin: 0 0 10px 0; font-size: 13px; font-weight: 600; color: #1a1a2e; }
        #legend div { margin-bottom: 6px; font-size: 12px; color: #444; }
        .mapboxgl-popup-content { font-size: 14px; padding: 14px 16px; max-width: 280px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
        .mapboxgl-popup-content strong { color: #3887be; display: block; margin-bottom: 4px; font-size: 15px; }
        .mapboxgl-popup-content .popup-subheader { color: #666; font-size: 13px; margin-bottom: 8px; }
        .mapboxgl-popup-content table { width: 100%; margin-top: 10px; border-collapse: collapse; }
        .mapboxgl-popup-content td { padding: 4px 0; color: #555; }
        .mapboxgl-popup-content td:last-child { text-align: right; font-weight: 600; color: #333; padding-left: 12px; }
        .mapboxgl-popup-tip { border-top-color: white !important; }
        .mapboxgl-ctrl-logo, .mapboxgl-ctrl-attrib { display: none !important; }
        #custom-logo { position: absolute; bottom: 10px; left: 10px; z-index: 2; }
        #custom-logo img { height: 80px; width: auto; }
        #custom-attribution { position: absolute; bottom: 10px; right: 10px; z-index: 2; background-color: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px; font-size: 12px; }
        #custom-attribution a { color: #333; text-decoration: none; }
        #custom-attribution a:hover { text-decoration: underline; }
        #charts-panel { position: absolute; top: 16px; right: 16px; width: 256px; max-height: calc(100vh - 260px); background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); overflow-y: auto; }
        #charts-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 14px; border-bottom: 1px solid rgba(0,0,0,0.08); background: rgba(255,255,255,0.95); border-radius: 12px 12px 0 0; position: sticky; top: 0; }
        #charts-header h4 { margin: 0; font-size: 13px; font-weight: 600; color: #1a1a2e; }
        #charts-close-btn { width: 22px; height: 22px; border-radius: 6px; background: transparent; border: none; cursor: pointer; font-size: 14px; color: #666; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        #charts-close-btn:hover { background: rgba(0,0,0,0.06); }
        .chart-container { padding: 10px; border-bottom: 1px solid rgba(0,0,0,0.06); }
        .chart-container:last-child { border-bottom: none; }
        .chart-container h5 { margin: 0 0 8px 0; font-size: 10px; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
        .chart-wrapper { position: relative; height: 100px; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255,255,255,0.9); z-index: 10; display: flex; justify-content: center; align-items: center; flex-direction: column; transition: opacity 0.3s ease; }
        .spinner { width: 48px; height: 48px; border: 4px solid #f0f2f5; border-top: 4px solid #3887be; border-radius: 50%; animation: spin 0.8s linear infinite; }
        #loader p { margin-top: 20px; font-size: 15px; color: #666; text-align: center; padding: 0 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #timeline-container { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(135deg, rgba(255,255,255,0.4), rgba(255,255,255,0.25)); backdrop-filter: blur(12px); border-radius: 0; padding: 3px 40px; box-shadow: 0 -2px 10px rgba(0,0,0,0.15); z-index: 1; }
        #timeline-info { display: flex; align-items: center; justify-content: space-between; font-size: 11px; color: #1a1a2e; margin-bottom: 3px; min-height: 20px; }
        #info-inline { display: none; flex: 1; text-align: center; font-weight: 500; }
        #info-inline .info-data { display: inline-flex; gap: 15px; }
        #info-inline .info-data > div { white-space: nowrap; }
        #timeline-zones { position: absolute; left: 20px; right: 20px; top: 12px; height: 6px; border-radius: 3px; pointer-events: none; }
        #timeline-slider { width: 100%; height: 6px; border-radius: 3px; background: rgba(200, 200, 200, 0.3); outline: none; -webkit-appearance: none; cursor: pointer; position: relative; z-index: 1; }
        #timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: linear-gradient(135deg, #4a9fd6, #3887be); cursor: pointer; box-shadow: 0 3px 8px rgba(0,0,0,0.3), 0 0 0 2px rgba(255,255,255,0.8); transition: transform 0.1s; }
        #timeline-slider::-webkit-slider-thumb:hover { transform: scale(1.15); }
        #timeline-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; background: linear-gradient(135deg, #4a9fd6, #3887be); cursor: pointer; border: 2px solid rgba(255,255,255,0.8); box-shadow: 0 3px 8px rgba(0,0,0,0.3); }
        #timeline-label { font-size: 11px; font-weight: 600; color: #1a1a2e; }
        #timeline-play-btn:hover { transform: scale(1.05); }
        .timeline-tick { position: absolute; width: 2px; height: 14px; background: rgba(0,0,0,0.35); top: -4px; pointer-events: none; border-radius: 1px; }
        @media (max-width: 900px) { #charts-panel { display: none; } #legend { display: none; } }
        @media (max-width: 600px) { #menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; border-radius: 0; transform: translateX(-100%); overflow-y: auto; transition: transform 0.2s ease; z-index: 10; } #menu.open { transform: translateX(0); } #menu-toggle { display: flex; } #menu-close { display: flex; } #timeline-container { padding: 3px 20px; } #timeline-info { font-size: 9px; } #info-inline .info-data { gap: 8px; } }
    </style>
</head>
<body>
<div id="loader"><div class="spinner"></div><p id="loader-text">Загрузка данных...</p></div>
<div id="map"></div>
<button id="menu-toggle">☰</button>
<div id="custom-logo"><img src="https://raw.githubusercontent.com/badmaev93/sea-map/refs/heads/main/150_logo75.png" alt="ДВНИГМИ"></div>
<div id="custom-attribution"><a href="https://www.mapbox.com/about/maps/" target="_blank">© Mapbox</a> | <a href="http://www.openstreetmap.org/copyright" target="_blank">© OpenStreetMap</a></div>
<div id="menu">
    <div id="menu-header"><button id="menu-close">✕</button></div>
    <h4>Параметр</h4>
    <div class="layer-group">
        <button id="btn-oxygen-points" class="active" data-param="oxygen">Кислород</button>
        <button id="btn-ph-points" data-param="ph">pH</button>
    </div>
    <h4>Горизонт</h4>
    <div class="horizon-group">
        <button class="horizon-btn active" data-value="0">Поверхность</button>
        <button class="horizon-btn" data-value="дно">Дно</button>
    </div>
    <div class="toggle-row"><span>Показывать подписи</span><label class="toggle-switch"><input type="checkbox" id="show-labels"><span class="toggle-slider"></span></label></div>
    <button id="download-btn" style="width: 40px; height: 40px; margin-top: 16px; padding: 0; border: none; background: white; border-radius: 8px; cursor: pointer; font-size: 20px; transition: all 0.15s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center;">⬇</button>
</div>
<div id="legend"></div>
<div id="timeline-container">
    <div id="timeline-info">
        <div id="timeline-label"></div>
        <div id="info-inline"></div>
        <button id="timeline-play-btn" style="width: 24px; height: 24px; border-radius: 50%; background: linear-gradient(135deg, #4a9fd6, #3887be); border: none; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.2); transition: transform 0.1s; flex-shrink: 0;">▶</button>
    </div>
    <div id="timeline-zones"></div>
    <input type="range" id="timeline-slider" min="0" max="100" value="0">
</div>
<div id="charts-panel" style="display: none;">
    <div id="charts-header">
        <h4 id="charts-title">Временные ряды</h4>
        <button id="charts-close-btn">✕</button>
    </div>
    <div class="chart-container"><h5 id="param-chart-title">Кислород <span style="font-size:8px;opacity:0.6;">мг/л</span></h5><div class="chart-wrapper"><canvas id="param-chart"></canvas></div></div>
    <div class="chart-container"><h5>Температура <span style="font-size:8px;opacity:0.6;">°C</span></h5><div class="chart-wrapper"><canvas id="temp-chart"></canvas></div></div>
    <div class="chart-container"><h5>Солёность <span style="font-size:8px;opacity:0.6;">PSU</span></h5><div class="chart-wrapper"><canvas id="salinity-chart"></canvas></div></div>
</div>
<script>
// Публичный токен Mapbox (безопасен для браузерного использования)
mapboxgl.accessToken = 'pk.eyJ1IjoiYm9sZWc5MzQiLCJhIjoiY2syY3pjeXFyMjN5aTNobzZmZGl5cng3aiJ9.ADhGQN0rFnGwPCk53capfQ';
const map = new mapboxgl.Map({ container: 'map', style: 'mapbox://styles/mapbox/light-v10', center: [132.026960, 43.130572], zoom: 8.95, attributionControl: false, preserveDrawingBuffer: true });
const config = { scales: { oxygen: { title: 'Кислород, мг/л', prop: 'oxygen_mgl', format: 1, breaks: [6, 8, 10], bands: ['#f46d43', '#d9ef8b', '#a6d96a', '#66bd63'], sizeConfig: { base: 16 } }, ph: { title: 'pH', prop: 'ph', format: 2, bands: ['#eff3ff', '#bdd7e7', '#6baed6'], sizeConfig: { base: 18 } } }, firstLabelLayerId: 'waterway-label' };
let paramChart = null, tempChart = null, salinityChart = null, fullData = [];
let state = { activeParam: 'oxygen', showLabels: false, horizon: '0', year: null, season: 'spring', selectedStation: null };
let timelineDates = [];
let timelineIndex = 0;
let timelineInterval = null;

function formatNumber(value, decimalPlaces) { if (typeof value !== 'number' || !isFinite(value)) return 'н/д'; return value.toFixed(decimalPlaces).replace('.', ','); }
function formatFullDateTime(dateStr, timeStr) { if (!dateStr || !timeStr) return 'Нет данных'; const dateParts = String(dateStr).split('/'); const timeParts = String(timeStr).split(':'); if (dateParts.length !== 3 || timeParts.length < 2) return 'Неверный формат'; const [month, day, year] = dateParts; const [hour, minute] = timeParts; return `${String(day).padStart(2, '0')}.${String(month).padStart(2, '0')}.${year} ${hour}:${minute}`; }
function generateDynamicBreaks(data, prop, numSteps) { if (!data || data.length === 0) return []; const values = data.map(d => d.properties[prop]).filter(v => typeof v === 'number' && isFinite(v)); if (values.length < 2) return values.length > 0 ? [values[0], values[0]] : []; const min = Math.min(...values); const max = Math.max(...values); if (min === max) return [min, max]; const step = (max - min) / numSteps; return Array.from({length: numSteps + 1}, (_, i) => parseFloat((min + i * step).toFixed(2))); }
function calculateBounds(features) { const bounds = new mapboxgl.LngLatBounds(); features.forEach(f => bounds.extend(f.geometry.coordinates)); return bounds; }
function calculateOutlierBounds(values) { if (!values || values.length < 4) return null; const sorted = [...values].sort((a, b) => a - b); const q1 = sorted[Math.floor(sorted.length * 0.25)]; const q3 = sorted[Math.floor(sorted.length * 0.75)]; const iqr = q3 - q1; return { lower: q1 - 1.5 * iqr, upper: q3 + 1.5 * iqr }; }

function updateLegend() {
    const paramConfig = config.scales[state.activeParam];
    if (!paramConfig) { document.getElementById('legend').innerHTML = ''; return; }
    let content = `<h4>${paramConfig.title}</h4>`;
    const key = `${state.season}_${state.horizon}`;
    const breaks = paramConfig.breaks || paramConfig.seasonHorizonBreaks?.[key];
    if (state.activeParam === 'oxygen' && paramConfig.breaks) {
        const bands = paramConfig.bands;
        content += `<div><span class="legend-key" style="background:${bands[0]}"></span>&lt; ${formatNumber(breaks[0], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[1]}"></span>${formatNumber(breaks[0], 1)} – ${formatNumber(breaks[1], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[2]}"></span>${formatNumber(breaks[1], 1)} – ${formatNumber(breaks[2], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[3]}"></span>≥ ${formatNumber(breaks[2], 1)}</div>`;
    } else {
        if (!breaks || breaks.length < 2) { document.getElementById('legend').innerHTML = content + 'Нет данных'; return; }
        for (let i = 0; i < paramConfig.bands.length; i++) { if (breaks[i + 1]) content += `<div><span class="legend-key" style="background:${paramConfig.bands[i]}"></span>${formatNumber(breaks[i], paramConfig.format)} – ${formatNumber(breaks[i + 1], paramConfig.format)}</div>`; }
    }
    document.getElementById('legend').innerHTML = content;
}

function parseDateTime(dateStr, timeStr) { if (!dateStr || !timeStr) return null; const dateParts = String(dateStr).split('/'); const timeParts = String(timeStr).split(':'); if (dateParts.length !== 3 || timeParts.length < 2) return null; const [month, day, year] = dateParts; const [hour, minute] = timeParts; return new Date(year, month - 1, day, hour, minute); }
function getSeason(dateStr) { if (!dateStr) return null; const dateParts = String(dateStr).split('/'); if (dateParts.length !== 3) return null; const month = parseInt(dateParts[0]); if (month >= 3 && month <= 5) return 'spring'; if (month >= 9 && month <= 11) return 'autumn'; return null; }

function updateCharts() {
    if (!state.selectedStation) {
        document.getElementById('charts-panel').style.display = 'none';
        return;
    }
    document.getElementById('charts-panel').style.display = 'block';
    const horizonText = state.horizon === '0' ? 'Поверхность' : 'Дно';
    document.getElementById('charts-title').textContent = `Станция ${state.selectedStation} - Горизонт: ${horizonText}`;

    let stationFeatures = fullData.filter(f => f.properties.station_id === state.selectedStation);
    const filteredFeatures = stationFeatures.filter(f => String(f.properties.horizon) === state.horizon);
    const dataPoints = filteredFeatures.map(f => ({
        datetime: parseDateTime(f.properties.date, f.properties.time),
        temp: f.properties.temp_c,
        salinity: f.properties.salinity_psu,
        oxygen: f.properties.oxygen_mgl,
        ph: f.properties.ph,
        station: f.properties.station_id,
        year: String(f.properties.date).split('/')[2],
        season: getSeason(f.properties.date),
        date: f.properties.date
    })).filter(d => d.datetime !== null).sort((a, b) => a.datetime - b.datetime);

    const monthNames = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
    const labels = dataPoints.map(d => monthNames[d.datetime.getMonth()]);

    const uniqueYears = [...new Set(dataPoints.map(d => d.year))];
    const yearLabel = uniqueYears.length === 1 ? uniqueYears[0] : `${uniqueYears[0]}-${uniqueYears[uniqueYears.length-1]}`;

    const createPointColors = (lineColor) => dataPoints.map(d => {
        const isCurrent = d.year === state.year && d.season === state.season;
        return isCurrent ? lineColor : `${lineColor}80`;
    });

    const pointRadius = dataPoints.map(d => {
        const isCurrent = d.year === state.year && d.season === state.season;
        return isCurrent ? 7 : 3;
    });

    const seasonSeparators = [];
    let currentSeason = dataPoints[0]?.season;
    let currentYear = dataPoints[0]?.year;
    dataPoints.forEach((d, idx) => {
        if ((d.season !== currentSeason || d.year !== currentYear) && idx > 0) {
            seasonSeparators.push({
                index: idx,
                season: currentSeason,
                year: currentYear
            });
            currentSeason = d.season;
            currentYear = d.year;
        }
    });

    const seasonLabelsPlugin = {
        id: 'seasonLabels',
        beforeDatasetsDraw: (chart) => {
            const ctx = chart.ctx;
            const chartArea = chart.chartArea;
            const xScale = chart.scales.x;

            ctx.save();

            let startIdx = 0;
            seasonSeparators.forEach(sep => {
                const endIdx = sep.index;
                if (sep.season === 'autumn') {
                    const x1 = xScale.getPixelForValue(startIdx);
                    const x2 = xScale.getPixelForValue(endIdx);
                    ctx.fillStyle = 'rgba(200, 200, 200, 0.15)';
                    ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
                }
                startIdx = endIdx;
            });

            if (dataPoints.length > 0 && dataPoints[dataPoints.length - 1].season === 'autumn') {
                const x1 = xScale.getPixelForValue(startIdx);
                const x2 = xScale.getPixelForValue(dataPoints.length - 1);
                ctx.fillStyle = 'rgba(200, 200, 200, 0.15)';
                ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
            }

            ctx.restore();
        },
        afterDraw: (chart) => {
            const ctx = chart.ctx;
            const chartArea = chart.chartArea;
            const xScale = chart.scales.x;

            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            const yearGroups = new Map();
            let startIdx = 0;

            seasonSeparators.forEach(sep => {
                const endIdx = sep.index;
                if (!yearGroups.has(sep.year)) {
                    yearGroups.set(sep.year, { start: startIdx, end: endIdx });
                } else {
                    yearGroups.get(sep.year).end = endIdx;
                }
                startIdx = endIdx;
            });

            if (dataPoints.length > 0) {
                const lastYear = dataPoints[dataPoints.length - 1].year;
                if (!yearGroups.has(lastYear)) {
                    yearGroups.set(lastYear, { start: startIdx, end: dataPoints.length - 1 });
                } else {
                    yearGroups.get(lastYear).end = dataPoints.length - 1;
                }
            }

            yearGroups.forEach((range, year) => {
                const centerIdx = (range.start + range.end) / 2;
                const x = xScale.getPixelForValue(centerIdx);
                ctx.fillText(year, x, chartArea.bottom + 18);
            });

            ctx.restore();
        }
    };

    const createChartOptions = () => ({
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { display: false },
            seasonLabels: {},
            tooltip: {
                callbacks: {
                    title: (items) => {
                        const idx = items[0].dataIndex;
                        const month = String(dataPoints[idx].datetime.getMonth() + 1).padStart(2, '0');
                        const day = String(dataPoints[idx].datetime.getDate()).padStart(2, '0');
                        return `${day}.${month}.${dataPoints[idx].year}`;
                    }
                }
            }
        },
        scales: {
            x: {
                ticks: { maxRotation: 0, minRotation: 0, font: { size: 9 } },
                grid: { display: false }
            },
            y: {
                grid: { color: 'rgba(0,0,0,0.06)' },
                ticks: { font: { size: 10 } }
            }
        },
        elements: {
            point: { hoverRadius: 5 },
            line: { tension: 0.3, borderWidth: 2 }
        }
    });

    if (paramChart) paramChart.destroy();
    if (tempChart) tempChart.destroy();
    if (salinityChart) salinityChart.destroy();

    const paramConfig = config.scales[state.activeParam];
    const paramTitleParts = paramConfig.title.split(', ');
    document.getElementById('param-chart-title').innerHTML = `${paramTitleParts[0]} <span style="font-size:9px;opacity:0.6;">${paramTitleParts[1] || ''}</span>`;
    const paramData = dataPoints.map(d => state.activeParam === 'oxygen' ? d.oxygen : d.ph);
    const paramColor = state.activeParam === 'oxygen' ? '#f46d43' : '#6baed6';

    paramChart = new Chart(document.getElementById('param-chart').getContext('2d'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                data: paramData,
                borderColor: paramColor,
                backgroundColor: `${paramColor}20`,
                fill: true,
                pointBackgroundColor: createPointColors(paramColor),
                pointBorderColor: createPointColors(paramColor),
                pointRadius: pointRadius
            }]
        },
        options: createChartOptions(),
        plugins: [seasonLabelsPlugin]
    });

    tempChart = new Chart(document.getElementById('temp-chart').getContext('2d'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                data: dataPoints.map(d => d.temp),
                borderColor: '#ff7f0e',
                backgroundColor: 'rgba(255, 127, 14, 0.1)',
                fill: true,
                pointBackgroundColor: createPointColors('#ff7f0e'),
                pointBorderColor: createPointColors('#ff7f0e'),
                pointRadius: pointRadius
            }]
        },
        options: createChartOptions(),
        plugins: [seasonLabelsPlugin]
    });

    salinityChart = new Chart(document.getElementById('salinity-chart').getContext('2d'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                data: dataPoints.map(d => d.salinity),
                borderColor: '#41b6c4',
                backgroundColor: 'rgba(65,182,196,0.1)',
                fill: true,
                pointBackgroundColor: createPointColors('#41b6c4'),
                pointBorderColor: createPointColors('#41b6c4'),
                pointRadius: pointRadius
            }]
        },
        options: createChartOptions(),
        plugins: [seasonLabelsPlugin]
    });
}

function updateLayers() {
    let yearFilteredFeatures = fullData.filter(f => String(f.properties.date).split('/')[2] === state.year);
    yearFilteredFeatures = yearFilteredFeatures.filter(f => getSeason(f.properties.date) === state.season);
    const filteredFeatures = yearFilteredFeatures.filter(f => String(f.properties.horizon) === state.horizon);
    const source = map.getSource('points-source');
    if (source) source.setData({ type: 'FeatureCollection', features: filteredFeatures });
    Object.keys(config.scales).forEach(param => {
        const isActive = param === state.activeParam;
        const pointLayerId = `${param}-points-layer`; const labelLayerId = `${param}-labels-layer`;
        if (isActive) {
            const paramConfig = config.scales[param];
            const key = `${state.season}_${state.horizon}`;
            const breaks = paramConfig.breaks || paramConfig.seasonHorizonBreaks?.[key];
            let colorExpression = '#cccccc';
            if (breaks && breaks.length > 1) { const colorStops = paramConfig.breaks ? paramConfig.breaks.flatMap((val, i) => [val, paramConfig.bands[i + 1]]) : breaks.slice(1).flatMap((val, i) => [val, paramConfig.bands[i + 1]]); colorExpression = ['step', ['get', paramConfig.prop], paramConfig.bands[0], ...colorStops]; }
            map.setPaintProperty(pointLayerId, 'circle-color', colorExpression);
            const outlierBounds = paramConfig.seasonHorizonOutliers?.[key];
            const radiusExpression = outlierBounds ? ['case', ['any', ['<', ['get', paramConfig.prop], outlierBounds.lower], ['>', ['get', paramConfig.prop], outlierBounds.upper]], paramConfig.sizeConfig.base * 1.6, paramConfig.sizeConfig.base] : paramConfig.sizeConfig.base;
            map.setPaintProperty(pointLayerId, 'circle-radius', radiusExpression);
        }
        if (map.getLayer(pointLayerId)) map.setLayoutProperty(pointLayerId, 'visibility', isActive ? 'visible' : 'none');
        if (map.getLayer(labelLayerId)) map.setLayoutProperty(labelLayerId, 'visibility', isActive && state.showLabels ? 'visible' : 'none');
    });
    updateLegend(); updateCharts();
}

function buildTimeline() {
    const dateMap = new Map();
    fullData.forEach(f => {
        const dateStr = f.properties.date;
        const year = String(dateStr).split('/')[2];
        const season = getSeason(dateStr);
        if (year && season) {
            const key = `${year}-${season}`;
            if (!dateMap.has(key)) {
                const seasonLabel = season === 'spring' ? 'Весна' : 'Осень';
                dateMap.set(key, { year: year, season: season, label: `${seasonLabel} ${year}` });
            }
        }
    });
    timelineDates = Array.from(dateMap.values()).sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return a.season === 'spring' ? -1 : 1;
    });
    const slider = document.getElementById('timeline-slider');
    slider.max = timelineDates.length - 1;
    slider.value = timelineDates.length - 1;
    timelineIndex = timelineDates.length - 1;
    if (timelineDates.length > 0) {
        const current = timelineDates[timelineIndex];
        state.year = current.year;
        state.season = current.season;
        updateTimelineLabel();
    }

    const zonesContainer = document.getElementById('timeline-zones');
    zonesContainer.innerHTML = '';
    timelineDates.forEach((date, index) => {
        const tick = document.createElement('div');
        tick.className = 'timeline-tick';
        const left = (index / (timelineDates.length - 1)) * 100;
        tick.style.left = `${left}%`;
        zonesContainer.appendChild(tick);
    });
}

function updateTimelineLabel() {
    const current = timelineDates[timelineIndex];
    document.getElementById('timeline-label').textContent = current.label;
    const slider = document.getElementById('timeline-slider');
    const percent = (timelineIndex / (timelineDates.length - 1)) * 100;
    slider.style.background = `linear-gradient(to right, #3887be ${percent}%, rgba(200, 200, 200, 0.3) ${percent}%)`;
}

function onTimelineChange(newIndex) {
    timelineIndex = newIndex;
    const current = timelineDates[timelineIndex];
    state.year = current.year;
    state.season = current.season;
    updateTimelineLabel();
    updateLayers();
}

function downloadMapAsImage() {
    const mapCanvas = map.getCanvas();
    const padding = 40;
    const headerHeight = 80;
    const legendWidth = 250;
    const legendPadding = 20;

    const canvas = document.createElement('canvas');
    canvas.width = mapCanvas.width + padding * 2;
    canvas.height = mapCanvas.height + padding * 2 + headerHeight;
    const ctx = canvas.getContext('2d');

    // Белый фон
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Заголовок
    const paramConfig = config.scales[state.activeParam];
    const seasonText = state.season === 'spring' ? 'Весна' : 'Осень';
    const horizonText = state.horizon === '0' ? 'Поверхность' : 'Дно';

    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText(`${paramConfig.title} – ${state.year} г., ${seasonText}`, padding, padding + 30);

    ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#666';
    ctx.fillText(`Горизонт: ${horizonText}`, padding, padding + 55);

    // Карта
    ctx.drawImage(mapCanvas, padding, padding + headerHeight);

    // Легенда
    const legendX = canvas.width - legendWidth - padding;
    const legendY = padding + headerHeight + 20;

    // Фон легенды
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.shadowColor = 'rgba(0,0,0,0.15)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 4;
    ctx.fillRect(legendX, legendY, legendWidth, 180);
    ctx.shadowColor = 'transparent';

    // Рамка легенды
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    ctx.strokeRect(legendX, legendY, legendWidth, 180);

    // Заголовок легенды
    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText(paramConfig.title, legendX + legendPadding, legendY + legendPadding + 15);

    // Элементы легенды
    const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
    let yOffset = legendY + legendPadding + 40;
    const keySize = 14;
    const itemSpacing = 30;

    ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#444';

    if (state.activeParam === 'oxygen' && paramConfig.breaks) {
        const bands = paramConfig.bands;
        const labels = [
            `< ${formatNumber(breaks[0], 1)}`,
            `${formatNumber(breaks[0], 1)} – ${formatNumber(breaks[1], 1)}`,
            `${formatNumber(breaks[1], 1)} – ${formatNumber(breaks[2], 1)}`,
            `≥ ${formatNumber(breaks[2], 1)}`
        ];

        labels.forEach((label, i) => {
            // Цветной квадрат
            ctx.fillStyle = bands[i];
            ctx.fillRect(legendX + legendPadding, yOffset - keySize + 2, keySize, keySize);

            // Текст
            ctx.fillStyle = '#444';
            ctx.fillText(label, legendX + legendPadding + keySize + 10, yOffset);
            yOffset += itemSpacing;
        });
    } else {
        if (breaks && breaks.length >= 2) {
            for (let i = 0; i < paramConfig.bands.length && breaks[i + 1]; i++) {
                // Цветной квадрат
                ctx.fillStyle = paramConfig.bands[i];
                ctx.fillRect(legendX + legendPadding, yOffset - keySize + 2, keySize, keySize);

                // Текст
                ctx.fillStyle = '#444';
                const label = `${formatNumber(breaks[i], paramConfig.format)} – ${formatNumber(breaks[i + 1], paramConfig.format)}`;
                ctx.fillText(label, legendX + legendPadding + keySize + 10, yOffset);
                yOffset += itemSpacing;
            }
        }
    }

    // Скачивание
    canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `карта_${state.activeParam}_${state.year}_${seasonText}_${horizonText}.png`;
        a.click();
        URL.revokeObjectURL(url);
    });
}

function setupControls() {
    document.querySelectorAll('.layer-group button').forEach(btn => { btn.addEventListener('click', e => { document.querySelectorAll('.layer-group button').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); state.activeParam = e.target.dataset.param; updateLayers(); }); });
    document.querySelectorAll('.horizon-btn').forEach(btn => { btn.addEventListener('click', e => { document.querySelectorAll('.horizon-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); state.horizon = e.target.dataset.value; updateLayers(); }); });
    document.getElementById('show-labels').addEventListener('change', e => { state.showLabels = e.target.checked; updateLayers(); });
    document.getElementById('download-btn').addEventListener('click', downloadMapAsImage);
    document.getElementById('timeline-slider').addEventListener('input', e => { onTimelineChange(parseInt(e.target.value)); });
    document.getElementById('menu-toggle').addEventListener('click', () => document.getElementById('menu').classList.add('open'));
    document.getElementById('menu-close').addEventListener('click', () => document.getElementById('menu').classList.remove('open'));
    document.getElementById('charts-close-btn').addEventListener('click', () => {
        state.selectedStation = null;
        document.getElementById('charts-panel').style.display = 'none';
        document.getElementById('info-inline').style.display = 'none';
    });
    document.getElementById('timeline-play-btn').addEventListener('click', () => {
        const playBtn = document.getElementById('timeline-play-btn');
        if (timelineInterval) {
            clearInterval(timelineInterval);
            timelineInterval = null;
            playBtn.textContent = '▶';
        } else {
            playBtn.textContent = '⏸';
            timelineInterval = setInterval(() => {
                if (timelineIndex < timelineDates.length - 1) {
                    onTimelineChange(timelineIndex + 1);
                    document.getElementById('timeline-slider').value = timelineIndex;
                } else {
                    clearInterval(timelineInterval);
                    timelineInterval = null;
                    playBtn.textContent = '▶';
                }
            }, 1000);
        }
    });
    map.on('click', e => {
        if (!e.originalEvent.defaultPrevented) {
            state.selectedStation = null;
            document.getElementById('charts-panel').style.display = 'none';
            document.getElementById('info-inline').style.display = 'none';
        }
    });
}

async function fetchWithRetries(url, retries = 3, delay = 5000) { const loaderText = document.getElementById('loader-text'); for (let i = 0; i < retries; i++) { try { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 60000); const response = await fetch(url, { signal: controller.signal }); clearTimeout(timeoutId); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response; } catch (error) { if (i === 0 && loaderText) loaderText.innerHTML = "Сервер запускается...<br>Подождите, пожалуйста."; if (i === retries - 1) throw error; await new Promise(resolve => setTimeout(resolve, delay)); } } }

async function initializeMap() {
    const loader = document.getElementById('loader'); const loaderText = document.getElementById('loader-text');
    try {
        const response = await fetchWithRetries('https://sea-data-api.onrender.com/api/data');
        const rawData = await response.json();
        const validData = rawData.filter(p => p.longitude != null && p.latitude != null);
        validData.forEach(p => { p.datetime_full_formatted = formatFullDateTime(p.date, p.time); p.oxygen_mgl_formatted = formatNumber(p.oxygen_mgl, 1); p.temp_c_formatted = formatNumber(p.temp_c, 1); p.ph_formatted = formatNumber(p.ph, 2); p.salinity_psu_formatted = formatNumber(p.salinity_psu, 2); });
        fullData = validData.map(p => ({ type: 'Feature', geometry: { type: 'Point', coordinates: [p.longitude, p.latitude] }, properties: p }));
        Object.entries(config.scales).forEach(([param, paramConfig]) => {
            if (!paramConfig.breaks) {
                paramConfig.seasonHorizonBreaks = {};
                paramConfig.seasonHorizonOutliers = {};
                ['spring', 'autumn'].forEach(season => {
                    ['0', 'дно'].forEach(horizon => {
                        const key = `${season}_${horizon}`;
                        const filteredData = fullData.filter(f =>
                            String(f.properties.horizon) === horizon &&
                            getSeason(f.properties.date) === season
                        );
                        paramConfig.seasonHorizonBreaks[key] = generateDynamicBreaks(filteredData, paramConfig.prop, paramConfig.bands.length);
                        paramConfig.seasonHorizonOutliers[key] = calculateOutlierBounds(filteredData.map(f => f.properties[paramConfig.prop]));
                    });
                });
            }
        });
        if (fullData.length > 0) { const bounds = calculateBounds(fullData); map.fitBounds(bounds, { padding: 50, duration: 0 }); const sw = bounds.getSouthWest(), ne = bounds.getNorthEast(); const lngDiff = ne.lng - sw.lng, latDiff = ne.lat - sw.lat, padding = 0.2; map.setMaxBounds(new mapboxgl.LngLatBounds([sw.lng - lngDiff * padding, sw.lat - latDiff * padding], [ne.lng + lngDiff * padding, ne.lat + latDiff * padding])); }
        map.addSource('points-source', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
        Object.entries(config.scales).forEach(([param, scale]) => { map.addLayer({ id: `${param}-points-layer`, type: 'circle', source: 'points-source', layout: { visibility: 'none' }, paint: { 'circle-color': '#cccccc', 'circle-stroke-width': 1.5, 'circle-stroke-color': '#fff', 'circle-radius': scale.sizeConfig.base } }, config.firstLabelLayerId); map.addLayer({ id: `${param}-labels-layer`, type: 'symbol', source: 'points-source', layout: { visibility: 'none', 'text-field': ['get', `${scale.prop}_formatted`], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10.5, 'text-allow-overlap': true, 'text-ignore-placement': true }, paint: { 'text-color': '#ffffff', 'text-halo-color': 'rgba(0, 0, 0, 0.85)', 'text-halo-width': 1.2 } }, config.firstLabelLayerId); });
        setupControls();
        buildTimeline();
        Object.keys(config.scales).forEach(param => { map.on('click', `${param}-points-layer`, e => { e.originalEvent.preventDefault(); const props = e.features[0].properties; state.selectedStation = props.station_id; updateCharts(); const infoInline = document.getElementById('info-inline'); infoInline.innerHTML = `Станция ${props.station_id} · ${props.bay} · Гориз.: ${props.horizon} · <span class="info-data"><span>t: ${props.temp_c_formatted}°C</span><span>S: ${props.salinity_psu_formatted}</span><span>O₂: ${props.oxygen_mgl_formatted}</span><span>pH: ${props.ph_formatted}</span></span>`; infoInline.style.display = 'flex'; }); map.on('mouseenter', `${param}-points-layer`, () => map.getCanvas().style.cursor = 'pointer'); map.on('mouseleave', `${param}-points-layer`, () => map.getCanvas().style.cursor = ''); });
        updateLayers();
        loader.style.opacity = 0; setTimeout(() => loader.style.display = 'none', 300);
    } catch (error) { console.error("Не удалось загрузить данные:", error); if (loaderText) { loader.querySelector('.spinner').style.display = 'none'; loaderText.innerHTML = "Ошибка загрузки данных.<br>Обновите страницу."; } }
}

map.on('load', () => { map.setLanguage('ru'); initializeMap(); });
</script>
</body>
</html>
