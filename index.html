<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>–ö–∞—Ä—Ç–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –º–æ—Ä—è</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        #menu-toggle { display: none; position: absolute; top: 16px; left: 16px; width: 44px; height: 44px; border-radius: 12px; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border: none; box-shadow: 0 4px 20px rgba(0,0,0,0.15); cursor: pointer; z-index: 2; font-size: 20px; align-items: center; justify-content: center; }
        #menu { position: absolute; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 16px; top: 16px; left: 16px; border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); width: 220px; }
        #menu-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(0,0,0,0.08); }
        #menu-header h3 { margin: 0; font-size: 15px; font-weight: 600; color: #1a1a2e; }
        #menu-close { width: 28px; height: 28px; border-radius: 8px; background: transparent; border: none; cursor: pointer; font-size: 18px; color: #666; display: none; align-items: center; justify-content: center; }
        #menu-close:hover { background: rgba(0,0,0,0.06); }
        #menu h4 { margin: 16px 0 10px 0; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: #888; }
        #menu h4:first-of-type { margin-top: 0; }
        .layer-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .layer-group button { border: none; background: #f0f2f5; padding: 10px 8px; border-radius: 8px; cursor: pointer; text-align: center; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; }
        .layer-group button:hover { background: #e4e6eb; }
        .layer-group button.active { background: linear-gradient(135deg, #3887be, #2d6a9f); color: white; box-shadow: 0 2px 8px rgba(56,135,190,0.3); }
        .select-wrapper { position: relative; }
        .select-wrapper::after { content: '\25BC'; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); font-size: 10px; color: #888; pointer-events: none; }
        #year-select { width: 100%; padding: 10px 12px; border: none; background: #f0f2f5; border-radius: 8px; font-size: 14px; font-weight: 500; color: #333; cursor: pointer; appearance: none; }
        #year-select:hover { background: #e4e6eb; }
        #year-select:focus { outline: none; box-shadow: 0 0 0 2px rgba(56,135,190,0.3); }
        .horizon-group { display: flex; gap: 8px; }
        .horizon-btn { flex: 1; padding: 10px; border: none; background: #f0f2f5; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; text-align: center; }
        .horizon-btn:hover { background: #e4e6eb; }
        .horizon-btn.active { background: #1a1a2e; color: white; }
        .season-btn { flex: 1; padding: 10px; border: none; background: #f0f2f5; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; color: #444; transition: all 0.15s ease; text-align: center; }
        .season-btn:hover { background: #e4e6eb; }
        .season-btn.active { background: #1a1a2e; color: white; }
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0,0,0,0.08); }
        .toggle-row span { font-size: 13px; color: #444; }
        .toggle-switch { position: relative; width: 44px; height: 24px; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background: #ccc; border-radius: 24px; transition: 0.2s ease; }
        .toggle-slider::before { position: absolute; content: ''; height: 18px; width: 18px; left: 3px; bottom: 3px; background: white; border-radius: 50%; transition: 0.2s ease; }
        .toggle-switch input:checked + .toggle-slider { background: #3887be; }
        .toggle-switch input:checked + .toggle-slider::before { transform: translateX(20px); }
        #legend { position: absolute; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); padding: 12px 16px; bottom: 100px; right: 16px; border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); }
        .legend-key { display: inline-block; width: 14px; height: 14px; margin-right: 8px; vertical-align: middle; border-radius: 4px; }
        #legend h4 { margin: 0 0 10px 0; font-size: 13px; font-weight: 600; color: #1a1a2e; }
        #legend div { margin-bottom: 6px; font-size: 12px; color: #444; }
        .mapboxgl-popup-content { font-size: 14px; padding: 14px 16px; max-width: 280px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); }
        .mapboxgl-popup-content strong { color: #3887be; display: block; margin-bottom: 4px; font-size: 15px; }
        .mapboxgl-popup-content .popup-subheader { color: #666; font-size: 13px; margin-bottom: 8px; }
        .mapboxgl-popup-content table { width: 100%; margin-top: 10px; border-collapse: collapse; }
        .mapboxgl-popup-content td { padding: 4px 0; color: #555; }
        .mapboxgl-popup-content td:last-child { text-align: right; font-weight: 600; color: #333; padding-left: 12px; }
        .mapboxgl-popup-tip { border-top-color: white !important; }
        .mapboxgl-ctrl-logo, .mapboxgl-ctrl-attrib { display: none !important; }
        #custom-logo { position: absolute; bottom: 10px; left: 10px; z-index: 2; }
        #custom-logo img { height: 80px; width: auto; }
        #custom-attribution { position: absolute; bottom: 10px; right: 10px; z-index: 2; background-color: rgba(255,255,255,0.7); padding: 2px 5px; border-radius: 3px; font-size: 12px; }
        #custom-attribution a { color: #333; text-decoration: none; }
        #custom-attribution a:hover { text-decoration: underline; }
        #charts-panel { position: absolute; top: 16px; right: 16px; width: 380px; max-height: calc(100vh - 80px); background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-radius: 12px; z-index: 1; box-shadow: 0 4px 20px rgba(0,0,0,0.15); overflow-y: auto; }
        #charts-panel h4 { margin: 0; padding: 14px 16px; font-size: 15px; font-weight: 600; color: #1a1a2e; border-bottom: 1px solid rgba(0,0,0,0.08); background: rgba(255,255,255,0.95); border-radius: 12px 12px 0 0; position: sticky; top: 0; }
        .chart-container { padding: 16px; border-bottom: 1px solid rgba(0,0,0,0.06); }
        .chart-container:last-child { border-bottom: none; }
        .chart-container h5 { margin: 0 0 12px 0; font-size: 12px; font-weight: 600; color: #888; text-transform: uppercase; letter-spacing: 0.5px; }
        .chart-wrapper { position: relative; height: 160px; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(255,255,255,0.9); z-index: 10; display: flex; justify-content: center; align-items: center; flex-direction: column; transition: opacity 0.3s ease; }
        .spinner { width: 48px; height: 48px; border: 4px solid #f0f2f5; border-top: 4px solid #3887be; border-radius: 50%; animation: spin 0.8s linear infinite; }
        #loader p { margin-top: 20px; font-size: 15px; color: #666; text-align: center; padding: 0 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #timeline-container { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 60%; max-width: 800px; background: rgba(255,255,255,0.3); backdrop-filter: blur(8px); border-radius: 20px; padding: 8px 16px; box-shadow: 0 2px 12px rgba(0,0,0,0.2); z-index: 1; border: 1px solid rgba(255,255,255,0.5); }
        #timeline-slider { width: 100%; height: 4px; border-radius: 2px; background: linear-gradient(to right, #3887be 0%, rgba(255,255,255,0.4) 0%); outline: none; -webkit-appearance: none; cursor: pointer; }
        #timeline-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #3887be; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #timeline-slider::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: #3887be; cursor: pointer; border: none; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #timeline-label { text-align: center; font-size: 11px; font-weight: 600; color: #1a1a2e; margin-top: 4px; text-shadow: 0 1px 2px rgba(255,255,255,0.8); }
        @media (max-width: 900px) { #charts-panel { display: none; } #timeline-container { width: 80%; } }
        @media (max-width: 600px) { #menu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; border-radius: 0; transform: translateX(-100%); overflow-y: auto; transition: transform 0.2s ease; } #menu.open { transform: translateX(0); } #menu-toggle { display: flex; } #menu-close { display: flex; } #legend { bottom: 100px; right: 10px; left: 10px; } }
    </style>
</head>
<body>
<div id="loader"><div class="spinner"></div><p id="loader-text">–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</p></div>
<div id="map"></div>
<button id="menu-toggle">‚ò∞</button>
<div id="custom-logo"><img src="https://raw.githubusercontent.com/badmaev93/sea-map/refs/heads/main/150_logo75.png" alt="–î–í–ù–ò–ì–ú–ò"></div>
<div id="custom-attribution"><a href="https://www.mapbox.com/about/maps/" target="_blank">¬© Mapbox</a> | <a href="http://www.openstreetmap.org/copyright" target="_blank">¬© OpenStreetMap</a></div>
<div id="menu">
    <div id="menu-header"><h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3><button id="menu-close">‚úï</button></div>
    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä</h4>
    <div class="layer-group">
        <button id="btn-oxygen-points" class="active" data-param="oxygen">–ö–∏—Å–ª–æ—Ä–æ–¥</button>
        <button id="btn-ph-points" data-param="ph">pH</button>
    </div>
    <h4>–ì–æ—Ä–∏–∑–æ–Ω—Ç</h4>
    <div class="horizon-group">
        <button class="horizon-btn active" data-value="0">–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å</button>
        <button class="horizon-btn" data-value="–¥–Ω–æ">–î–Ω–æ</button>
    </div>
    <div class="toggle-row"><span>–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å–∏</span><label class="toggle-switch"><input type="checkbox" id="show-labels"><span class="toggle-slider"></span></label></div>
    <button id="download-btn" style="width: 100%; margin-top: 16px; padding: 12px; border: none; background: linear-gradient(135deg, #3887be, #2d6a9f); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; transition: all 0.15s ease;">üì• –°–∫–∞—á–∞—Ç—å –∫–∞—Ä—Ç—É</button>
</div>
<div id="legend"></div>
<div id="timeline-container">
    <input type="range" id="timeline-slider" min="0" max="100" value="0">
    <div id="timeline-label"></div>
</div>
<div id="charts-panel" style="display: none;">
    <h4 id="charts-title">–í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä—è–¥—ã</h4>
    <div class="chart-container"><h5>–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞, ¬∞C</h5><div class="chart-wrapper"><canvas id="temp-chart"></canvas></div></div>
    <div class="chart-container"><h5>–°–æ–ª—ë–Ω–æ—Å—Ç—å, PSU</h5><div class="chart-wrapper"><canvas id="salinity-chart"></canvas></div></div>
</div>
<script>
// –ü—É–±–ª–∏—á–Ω—ã–π —Ç–æ–∫–µ–Ω Mapbox (–±–µ–∑–æ–ø–∞—Å–µ–Ω –¥–ª—è –±—Ä–∞—É–∑–µ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)
mapboxgl.accessToken = 'pk.eyJ1IjoiYm9sZWc5MzQiLCJhIjoiY2syY3pjeXFyMjN5aTNobzZmZGl5cng3aiJ9.ADhGQN0rFnGwPCk53capfQ';
const map = new mapboxgl.Map({ container: 'map', style: 'mapbox://styles/mapbox/light-v10', center: [132.026960, 43.130572], zoom: 8.95, attributionControl: false, preserveDrawingBuffer: true });
const config = { scales: { oxygen: { title: '–ö–∏—Å–ª–æ—Ä–æ–¥, –º–≥/–ª', prop: 'oxygen_mgl', format: 1, breaks: [6, 8, 10], bands: ['#f46d43', '#d9ef8b', '#a6d96a', '#66bd63'], sizeConfig: { base: 16 } }, ph: { title: 'pH', prop: 'ph', format: 2, bands: ['#eff3ff', '#bdd7e7', '#6baed6'], sizeConfig: { base: 18 } } }, firstLabelLayerId: 'waterway-label' };
let tempChart = null, salinityChart = null, fullData = [];
let state = { activeParam: 'oxygen', showLabels: false, horizon: '0', year: null, season: 'spring', selectedStation: null };
let timelineDates = [];
let timelineIndex = 0;

function formatNumber(value, decimalPlaces) { if (typeof value !== 'number' || !isFinite(value)) return '–Ω/–¥'; return value.toFixed(decimalPlaces).replace('.', ','); }
function formatFullDateTime(dateStr, timeStr) { if (!dateStr || !timeStr) return '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'; const dateParts = String(dateStr).split('/'); const timeParts = String(timeStr).split(':'); if (dateParts.length !== 3 || timeParts.length < 2) return '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç'; const [month, day, year] = dateParts; const [hour, minute] = timeParts; return `${String(day).padStart(2, '0')}.${String(month).padStart(2, '0')}.${year} ${hour}:${minute}`; }
function generateDynamicBreaks(data, prop, numSteps) { if (!data || data.length === 0) return []; const values = data.map(d => d.properties[prop]).filter(v => typeof v === 'number' && isFinite(v)); if (values.length < 2) return values.length > 0 ? [values[0], values[0]] : []; const min = Math.min(...values); const max = Math.max(...values); if (min === max) return [min, max]; const step = (max - min) / numSteps; return Array.from({length: numSteps + 1}, (_, i) => parseFloat((min + i * step).toFixed(2))); }
function calculateBounds(features) { const bounds = new mapboxgl.LngLatBounds(); features.forEach(f => bounds.extend(f.geometry.coordinates)); return bounds; }
function calculateOutlierBounds(values) { if (!values || values.length < 4) return null; const sorted = [...values].sort((a, b) => a - b); const q1 = sorted[Math.floor(sorted.length * 0.25)]; const q3 = sorted[Math.floor(sorted.length * 0.75)]; const iqr = q3 - q1; return { lower: q1 - 1.5 * iqr, upper: q3 + 1.5 * iqr }; }

function updateLegend() {
    const paramConfig = config.scales[state.activeParam];
    if (!paramConfig) { document.getElementById('legend').innerHTML = ''; return; }
    let content = `<h4>${paramConfig.title}</h4>`;
    const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
    if (state.activeParam === 'oxygen' && paramConfig.breaks) {
        const bands = paramConfig.bands;
        content += `<div><span class="legend-key" style="background:${bands[0]}"></span>&lt; ${formatNumber(breaks[0], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[1]}"></span>${formatNumber(breaks[0], 1)} ‚Äì ${formatNumber(breaks[1], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[2]}"></span>${formatNumber(breaks[1], 1)} ‚Äì ${formatNumber(breaks[2], 1)}</div>`;
        content += `<div><span class="legend-key" style="background:${bands[3]}"></span>‚â• ${formatNumber(breaks[2], 1)}</div>`;
    } else {
        if (!breaks || breaks.length < 2) { document.getElementById('legend').innerHTML = content + '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'; return; }
        for (let i = 0; i < paramConfig.bands.length; i++) { if (breaks[i + 1]) content += `<div><span class="legend-key" style="background:${paramConfig.bands[i]}"></span>${formatNumber(breaks[i], paramConfig.format)} ‚Äì ${formatNumber(breaks[i + 1], paramConfig.format)}</div>`; }
    }
    document.getElementById('legend').innerHTML = content;
}

function parseDateTime(dateStr, timeStr) { if (!dateStr || !timeStr) return null; const dateParts = String(dateStr).split('/'); const timeParts = String(timeStr).split(':'); if (dateParts.length !== 3 || timeParts.length < 2) return null; const [month, day, year] = dateParts; const [hour, minute] = timeParts; return new Date(year, month - 1, day, hour, minute); }
function getSeason(dateStr) { if (!dateStr) return null; const dateParts = String(dateStr).split('/'); if (dateParts.length !== 3) return null; const month = parseInt(dateParts[0]); if (month >= 3 && month <= 5) return 'spring'; if (month >= 9 && month <= 11) return 'autumn'; return null; }

function updateCharts() {
    if (!state.selectedStation) {
        document.getElementById('charts-panel').style.display = 'none';
        return;
    }
    document.getElementById('charts-panel').style.display = 'block';
    document.getElementById('charts-title').textContent = `–í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä—è–¥—ã ‚Äì –°—Ç–∞–Ω—Ü–∏—è ${state.selectedStation}`;

    let stationFeatures = fullData.filter(f => f.properties.station_id === state.selectedStation);
    const filteredFeatures = stationFeatures.filter(f => String(f.properties.horizon) === state.horizon);
    const dataPoints = filteredFeatures.map(f => ({
        datetime: parseDateTime(f.properties.date, f.properties.time),
        temp: f.properties.temp_c,
        salinity: f.properties.salinity_psu,
        station: f.properties.station_id,
        year: String(f.properties.date).split('/')[2],
        season: getSeason(f.properties.date),
        date: f.properties.date
    })).filter(d => d.datetime !== null).sort((a, b) => a.datetime - b.datetime);

    const labels = dataPoints.map(d => {
        const day = String(d.datetime.getDate()).padStart(2, '0');
        const month = String(d.datetime.getMonth() + 1).padStart(2, '0');
        const year = d.datetime.getFullYear();
        return `${day}.${month}.${year}`;
    });

    const pointColors = dataPoints.map(d => {
        const isCurrent = d.year === state.year && d.season === state.season;
        if (isCurrent) return 'rgba(255, 99, 132, 0.8)';
        return d.season === 'spring' ? 'rgba(144, 238, 144, 0.3)' : 'rgba(255, 200, 124, 0.3)';
    });

    const pointRadius = dataPoints.map(d => {
        const isCurrent = d.year === state.year && d.season === state.season;
        return isCurrent ? 7 : 3;
    });

    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { display: false },
            tooltip: {
                callbacks: {
                    title: (items) => {
                        const idx = items[0].dataIndex;
                        const seasonText = dataPoints[idx].season === 'spring' ? '–í–µ—Å–Ω–∞' : '–û—Å–µ–Ω—å';
                        return `${labels[idx]}\n${dataPoints[idx].year}, ${seasonText}`;
                    }
                }
            }
        },
        scales: {
            x: {
                ticks: { maxRotation: 45, minRotation: 45, font: { size: 10 } },
                grid: { display: false }
            },
            y: {
                grid: { color: 'rgba(0,0,0,0.06)' },
                ticks: { font: { size: 10 } }
            }
        },
        elements: {
            point: { hoverRadius: 5 },
            line: { tension: 0.3, borderWidth: 2 }
        }
    };

    if (tempChart) tempChart.destroy();
    if (salinityChart) salinityChart.destroy();

    tempChart = new Chart(document.getElementById('temp-chart').getContext('2d'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                data: dataPoints.map(d => d.temp),
                borderColor: '#f46d43',
                backgroundColor: 'rgba(244,109,67,0.1)',
                fill: true,
                pointBackgroundColor: pointColors,
                pointBorderColor: pointColors,
                pointRadius: pointRadius
            }]
        },
        options: chartOptions
    });

    salinityChart = new Chart(document.getElementById('salinity-chart').getContext('2d'), {
        type: 'line',
        data: {
            labels,
            datasets: [{
                data: dataPoints.map(d => d.salinity),
                borderColor: '#41b6c4',
                backgroundColor: 'rgba(65,182,196,0.1)',
                fill: true,
                pointBackgroundColor: pointColors,
                pointBorderColor: pointColors,
                pointRadius: pointRadius
            }]
        },
        options: chartOptions
    });
}

function updateLayers() {
    let yearFilteredFeatures = fullData.filter(f => String(f.properties.date).split('/')[2] === state.year);
    yearFilteredFeatures = yearFilteredFeatures.filter(f => getSeason(f.properties.date) === state.season);
    const filteredFeatures = yearFilteredFeatures.filter(f => String(f.properties.horizon) === state.horizon);
    const source = map.getSource('points-source');
    if (source) source.setData({ type: 'FeatureCollection', features: filteredFeatures });
    Object.keys(config.scales).forEach(param => {
        const isActive = param === state.activeParam;
        const pointLayerId = `${param}-points-layer`; const labelLayerId = `${param}-labels-layer`;
        if (isActive) {
            const paramConfig = config.scales[param];
            const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
            let colorExpression = '#cccccc';
            if (breaks && breaks.length > 1) { const colorStops = paramConfig.breaks ? paramConfig.breaks.flatMap((val, i) => [val, paramConfig.bands[i + 1]]) : breaks.slice(1).flatMap((val, i) => [val, paramConfig.bands[i + 1]]); colorExpression = ['step', ['get', paramConfig.prop], paramConfig.bands[0], ...colorStops]; }
            map.setPaintProperty(pointLayerId, 'circle-color', colorExpression);
            const outlierBounds = state.horizon === '0' ? paramConfig.surfaceOutlierBounds : paramConfig.bottomOutlierBounds;
            const radiusExpression = outlierBounds ? ['case', ['any', ['<', ['get', paramConfig.prop], outlierBounds.lower], ['>', ['get', paramConfig.prop], outlierBounds.upper]], paramConfig.sizeConfig.base * 1.6, paramConfig.sizeConfig.base] : paramConfig.sizeConfig.base;
            map.setPaintProperty(pointLayerId, 'circle-radius', radiusExpression);
        }
        if (map.getLayer(pointLayerId)) map.setLayoutProperty(pointLayerId, 'visibility', isActive ? 'visible' : 'none');
        if (map.getLayer(labelLayerId)) map.setLayoutProperty(labelLayerId, 'visibility', isActive && state.showLabels ? 'visible' : 'none');
    });
    updateLegend(); updateCharts();
}

function buildTimeline() {
    const dateMap = new Map();
    fullData.forEach(f => {
        const dateStr = f.properties.date;
        const year = String(dateStr).split('/')[2];
        const season = getSeason(dateStr);
        if (year && season) {
            const key = `${year}-${season}`;
            if (!dateMap.has(key)) {
                const seasonLabel = season === 'spring' ? '–í–µ—Å–Ω–∞' : '–û—Å–µ–Ω—å';
                dateMap.set(key, { year: year, season: season, label: `${seasonLabel} ${year}` });
            }
        }
    });
    timelineDates = Array.from(dateMap.values()).sort((a, b) => {
        if (a.year !== b.year) return a.year - b.year;
        return a.season === 'spring' ? -1 : 1;
    });
    const slider = document.getElementById('timeline-slider');
    slider.max = timelineDates.length - 1;
    slider.value = timelineDates.length - 1;
    timelineIndex = timelineDates.length - 1;
    if (timelineDates.length > 0) {
        const current = timelineDates[timelineIndex];
        state.year = current.year;
        state.season = current.season;
        updateTimelineLabel();
    }
}

function updateTimelineLabel() {
    const current = timelineDates[timelineIndex];
    document.getElementById('timeline-label').textContent = current.label;
    const slider = document.getElementById('timeline-slider');
    const percent = (timelineIndex / (timelineDates.length - 1)) * 100;
    slider.style.background = `linear-gradient(to right, #3887be ${percent}%, rgba(255,255,255,0.4) ${percent}%)`;
}

function onTimelineChange(newIndex) {
    timelineIndex = newIndex;
    const current = timelineDates[timelineIndex];
    state.year = current.year;
    state.season = current.season;
    updateTimelineLabel();
    updateLayers();
}

function downloadMapAsImage() {
    const mapCanvas = map.getCanvas();
    const padding = 40;
    const headerHeight = 80;
    const legendWidth = 250;
    const legendPadding = 20;

    const canvas = document.createElement('canvas');
    canvas.width = mapCanvas.width + padding * 2;
    canvas.height = mapCanvas.height + padding * 2 + headerHeight;
    const ctx = canvas.getContext('2d');

    // –ë–µ–ª—ã–π —Ñ–æ–Ω
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫
    const paramConfig = config.scales[state.activeParam];
    const seasonText = state.season === 'spring' ? '–í–µ—Å–Ω–∞' : '–û—Å–µ–Ω—å';
    const horizonText = state.horizon === '0' ? '–ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å' : '–î–Ω–æ';

    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 24px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText(`${paramConfig.title} ‚Äì ${state.year} –≥., ${seasonText}`, padding, padding + 30);

    ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#666';
    ctx.fillText(`–ì–æ—Ä–∏–∑–æ–Ω—Ç: ${horizonText}`, padding, padding + 55);

    // –ö–∞—Ä—Ç–∞
    ctx.drawImage(mapCanvas, padding, padding + headerHeight);

    // –õ–µ–≥–µ–Ω–¥–∞
    const legendX = canvas.width - legendWidth - padding;
    const legendY = padding + headerHeight + 20;

    // –§–æ–Ω –ª–µ–≥–µ–Ω–¥—ã
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.shadowColor = 'rgba(0,0,0,0.15)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 4;
    ctx.fillRect(legendX, legendY, legendWidth, 180);
    ctx.shadowColor = 'transparent';

    // –†–∞–º–∫–∞ –ª–µ–≥–µ–Ω–¥—ã
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    ctx.strokeRect(legendX, legendY, legendWidth, 180);

    // –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ª–µ–≥–µ–Ω–¥—ã
    ctx.fillStyle = '#1a1a2e';
    ctx.font = 'bold 15px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillText(paramConfig.title, legendX + legendPadding, legendY + legendPadding + 15);

    // –≠–ª–µ–º–µ–Ω—Ç—ã –ª–µ–≥–µ–Ω–¥—ã
    const breaks = paramConfig.breaks || (state.horizon === '0' ? paramConfig.surfaceBreaks : paramConfig.bottomBreaks);
    let yOffset = legendY + legendPadding + 40;
    const keySize = 14;
    const itemSpacing = 30;

    ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
    ctx.fillStyle = '#444';

    if (state.activeParam === 'oxygen' && paramConfig.breaks) {
        const bands = paramConfig.bands;
        const labels = [
            `< ${formatNumber(breaks[0], 1)}`,
            `${formatNumber(breaks[0], 1)} ‚Äì ${formatNumber(breaks[1], 1)}`,
            `${formatNumber(breaks[1], 1)} ‚Äì ${formatNumber(breaks[2], 1)}`,
            `‚â• ${formatNumber(breaks[2], 1)}`
        ];

        labels.forEach((label, i) => {
            // –¶–≤–µ—Ç–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç
            ctx.fillStyle = bands[i];
            ctx.fillRect(legendX + legendPadding, yOffset - keySize + 2, keySize, keySize);

            // –¢–µ–∫—Å—Ç
            ctx.fillStyle = '#444';
            ctx.fillText(label, legendX + legendPadding + keySize + 10, yOffset);
            yOffset += itemSpacing;
        });
    } else {
        if (breaks && breaks.length >= 2) {
            for (let i = 0; i < paramConfig.bands.length && breaks[i + 1]; i++) {
                // –¶–≤–µ—Ç–Ω–æ–π –∫–≤–∞–¥—Ä–∞—Ç
                ctx.fillStyle = paramConfig.bands[i];
                ctx.fillRect(legendX + legendPadding, yOffset - keySize + 2, keySize, keySize);

                // –¢–µ–∫—Å—Ç
                ctx.fillStyle = '#444';
                const label = `${formatNumber(breaks[i], paramConfig.format)} ‚Äì ${formatNumber(breaks[i + 1], paramConfig.format)}`;
                ctx.fillText(label, legendX + legendPadding + keySize + 10, yOffset);
                yOffset += itemSpacing;
            }
        }
    }

    // –°–∫–∞—á–∏–≤–∞–Ω–∏–µ
    canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `–∫–∞—Ä—Ç–∞_${state.activeParam}_${state.year}_${seasonText}_${horizonText}.png`;
        a.click();
        URL.revokeObjectURL(url);
    });
}

function setupControls() {
    document.querySelectorAll('.layer-group button').forEach(btn => { btn.addEventListener('click', e => { document.querySelectorAll('.layer-group button').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); state.activeParam = e.target.dataset.param; updateLayers(); }); });
    document.querySelectorAll('.horizon-btn').forEach(btn => { btn.addEventListener('click', e => { document.querySelectorAll('.horizon-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); state.horizon = e.target.dataset.value; updateLayers(); }); });
    document.getElementById('show-labels').addEventListener('change', e => { state.showLabels = e.target.checked; updateLayers(); });
    document.getElementById('download-btn').addEventListener('click', downloadMapAsImage);
    document.getElementById('timeline-slider').addEventListener('input', e => { onTimelineChange(parseInt(e.target.value)); });
    document.getElementById('menu-toggle').addEventListener('click', () => document.getElementById('menu').classList.add('open'));
    document.getElementById('menu-close').addEventListener('click', () => document.getElementById('menu').classList.remove('open'));
    map.on('click', e => {
        if (!e.originalEvent.defaultPrevented) {
            state.selectedStation = null;
            document.getElementById('charts-panel').style.display = 'none';
        }
    });
}

async function fetchWithRetries(url, retries = 3, delay = 5000) { const loaderText = document.getElementById('loader-text'); for (let i = 0; i < retries; i++) { try { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 60000); const response = await fetch(url, { signal: controller.signal }); clearTimeout(timeoutId); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return response; } catch (error) { if (i === 0 && loaderText) loaderText.innerHTML = "–°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...<br>–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞."; if (i === retries - 1) throw error; await new Promise(resolve => setTimeout(resolve, delay)); } } }

async function initializeMap() {
    const loader = document.getElementById('loader'); const loaderText = document.getElementById('loader-text');
    try {
        const response = await fetchWithRetries('https://sea-data-api.onrender.com/api/data');
        const rawData = await response.json();
        const validData = rawData.filter(p => p.longitude != null && p.latitude != null);
        validData.forEach(p => { p.datetime_full_formatted = formatFullDateTime(p.date, p.time); p.oxygen_mgl_formatted = formatNumber(p.oxygen_mgl, 1); p.temp_c_formatted = formatNumber(p.temp_c, 1); p.ph_formatted = formatNumber(p.ph, 2); p.salinity_psu_formatted = formatNumber(p.salinity_psu, 2); });
        fullData = validData.map(p => ({ type: 'Feature', geometry: { type: 'Point', coordinates: [p.longitude, p.latitude] }, properties: p }));
        Object.entries(config.scales).forEach(([param, paramConfig]) => { if (!paramConfig.breaks) { const surfaceData = fullData.filter(f => String(f.properties.horizon) === '0'); paramConfig.surfaceBreaks = generateDynamicBreaks(surfaceData, paramConfig.prop, paramConfig.bands.length); paramConfig.surfaceOutlierBounds = calculateOutlierBounds(surfaceData.map(f => f.properties[paramConfig.prop])); const bottomData = fullData.filter(f => String(f.properties.horizon) === '–¥–Ω–æ'); paramConfig.bottomBreaks = generateDynamicBreaks(bottomData, paramConfig.prop, paramConfig.bands.length); paramConfig.bottomOutlierBounds = calculateOutlierBounds(bottomData.map(f => f.properties[paramConfig.prop])); } });
        if (fullData.length > 0) { const bounds = calculateBounds(fullData); map.fitBounds(bounds, { padding: 50, duration: 0 }); const sw = bounds.getSouthWest(), ne = bounds.getNorthEast(); const lngDiff = ne.lng - sw.lng, latDiff = ne.lat - sw.lat, padding = 0.2; map.setMaxBounds(new mapboxgl.LngLatBounds([sw.lng - lngDiff * padding, sw.lat - latDiff * padding], [ne.lng + lngDiff * padding, ne.lat + latDiff * padding])); }
        map.addSource('points-source', { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
        Object.entries(config.scales).forEach(([param, scale]) => { map.addLayer({ id: `${param}-points-layer`, type: 'circle', source: 'points-source', layout: { visibility: 'none' }, paint: { 'circle-color': '#cccccc', 'circle-stroke-width': 1.5, 'circle-stroke-color': '#fff', 'circle-radius': scale.sizeConfig.base } }, config.firstLabelLayerId); map.addLayer({ id: `${param}-labels-layer`, type: 'symbol', source: 'points-source', layout: { visibility: 'none', 'text-field': ['get', `${scale.prop}_formatted`], 'text-font': ['Open Sans Semibold', 'Arial Unicode MS Bold'], 'text-size': 10.5, 'text-allow-overlap': true, 'text-ignore-placement': true }, paint: { 'text-color': '#ffffff', 'text-halo-color': 'rgba(0, 0, 0, 0.85)', 'text-halo-width': 1.2 } }, config.firstLabelLayerId); });
        setupControls();
        buildTimeline();
        Object.keys(config.scales).forEach(param => { map.on('click', `${param}-points-layer`, e => { e.originalEvent.preventDefault(); const props = e.features[0].properties; state.selectedStation = props.station_id; updateCharts(); new mapboxgl.Popup().setLngLat(e.lngLat).setHTML(`<strong>–°—Ç–∞–Ω—Ü–∏—è ${props.station_id}</strong><div class="popup-subheader">${props.bay}</div><div style="color:#888;font-size:12px;">–ì–æ—Ä–∏–∑–æ–Ω—Ç: ${props.horizon} ¬∑ ${props.datetime_full_formatted}</div><table><tr><td>–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞</td><td>${props.temp_c_formatted}¬∞C</td></tr><tr><td>–°–æ–ª—ë–Ω–æ—Å—Ç—å</td><td>${props.salinity_psu_formatted} PSU</td></tr><tr><td>–ö–∏—Å–ª–æ—Ä–æ–¥</td><td>${props.oxygen_mgl_formatted} –º–≥/–ª</td></tr><tr><td>pH</td><td>${props.ph_formatted}</td></tr></table>`).addTo(map); }); map.on('mouseenter', `${param}-points-layer`, () => map.getCanvas().style.cursor = 'pointer'); map.on('mouseleave', `${param}-points-layer`, () => map.getCanvas().style.cursor = ''); });
        updateLayers();
        loader.style.opacity = 0; setTimeout(() => loader.style.display = 'none', 300);
    } catch (error) { console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ:", error); if (loaderText) { loader.querySelector('.spinner').style.display = 'none'; loaderText.innerHTML = "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö.<br>–û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É."; } }
}

map.on('load', () => { map.setLanguage('ru'); initializeMap(); });
</script>
</body>
</html>
